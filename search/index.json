[{"content":"工具 SaveImage 1 2 3 4 5 6 7 8 //保存最后的图像 ModifyLastRunRecord //MessageBox.Show(\u0026#34;需要保存\u0026#34;); CogImageFile myImageFile=new cogImageFile(); string name=System.DateTime.Now.ToString(\u0026#34;yyyyMMddHHmmss\u0026#34;) +\u0026#34;.bmp\u0026#34;; string filename Path.Combine(\u0026#34;D:\u0026#34;, name); myImageFile.Open(filename, CogImageFileModeConstants.Write);//添加要保存的图像 myImageFile.Append(Inputs.0utputImage); myImageFile.c1ose(); 显示 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 List\u0026lt;ICogGraphic\u0026gt; list = new List\u0026lt;ICogGraphic\u0026gt;(); AddLabel(x, y, dis.ToString(\u0026#34;0.00\u0026#34;), false, fl2.InputImage.SelectedSpaceName); public void AddLabel(double x, double y, string text, bool Re, string sapcename) { CogGraphicLabel label = new CogGraphicLabel(); label.SetXYText(x, y, text); label.Color = Re ? CogColorConstants.Green : CogColorConstants.Red; label.Rotation = CogMisc.DegToRad(0); label.Alignment = CogGraphicLabelAlignmentConstants.BottomLeft; label.SelectedSpaceName = sapcename; label.Font = new Font(\u0026#34;微软雅黑\u0026#34;, 10); list.Add(label); } #region When the Last Run Record is Created /// \u0026lt;summary\u0026gt; /// Called when the last run record may have changed and is being reconstructed /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;lastRecord\u0026#34;\u0026gt; /// The new last run record is available to be initialized or customized.\u0026lt;/param\u0026gt; public override void ModifyLastRunRecord(Cognex.VisionPro.ICogRecord lastRecord) { foreach ( var item in list) { mToolBlock.AddGraphicToRunRecord(item, lastRecord, lastRecord.SubRecords[0].RecordKey, \u0026#34;\u0026#34;); } } #endregion 保存数据 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 public void SaveCsv1(float weight_value, string StartTime, string path) { string Data = string.Empty; Data += weight_value + \u0026#34;,\u0026#34;; Data += StartTime; if (!Directory.Exists(path)) { Directory.CreateDirectory(path); } string filepath = path + \u0026#34;\\\\\u0026#34; + DateTime.Now.ToString(\u0026#34;yyyyMMdd\u0026#34;) + \u0026#34;.csv\u0026#34;; if (!File.Exists(filepath)) { File.Create(filepath).Dispose(); using (StreamWriter sw = new StreamWriter(filepath, true)) { sw.WriteLine(\u0026#34;Weight\u0026#34; + \u0026#34;,\u0026#34; + \u0026#34;Time\u0026#34;); // 第一行 sw.Close(); } } using (StreamWriter sw = new StreamWriter(filepath, true)) { sw.WriteLine(Data); // 内容 sw.Close(); } } CSV1(DateTime.Now.ToString(\u0026#34;HH:mm:ss\u0026#34;) + \u0026#34;,\u0026#34; + Data_Str1 + l, @\u0026#34;E:\\\\Data\\\\Cam1\\\\第一段\\\\Up_Data\u0026#34;); #region 保存数据1 string Data_Name1; public void CSV1(string Data, string path) { int Long_Caliper_Count = (int) mToolBlock.Inputs[\u0026#34;Long_Caliper_Count\u0026#34;].Value; //int Short_Caliper_Count = (int) mToolBlock.Inputs[\u0026#34;Short_Caliper_Count\u0026#34;].Value; if (!Directory.Exists(path)) { Directory.CreateDirectory(path); } string filepath = path + \u0026#34;\\\\\u0026#34; + DateTime.Now.ToString(\u0026#34;yyyyMMdd\u0026#34;) + \u0026#34;.csv\u0026#34;; if (!File.Exists(filepath)) { File.Create(filepath).Dispose(); using (StreamWriter sw = new StreamWriter(filepath, true)) { for (int i = 0; i \u0026lt; Long_Caliper_Count; i++) { Data_Name1 += \u0026#34;Distance\u0026#34; + (i + 1) + \u0026#34;,\u0026#34;; } sw.WriteLine(\u0026#34;Time,\u0026#34; + Data_Name1 + \u0026#34;,Result\u0026#34;); sw.Close(); } } using (StreamWriter sw = new StreamWriter(filepath, true)) { sw.WriteLine(Data); sw.Close(); } } #endregion PMA 排序 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 //冒泡排序 CogPMAlignResult t_PMAlignResult; for (int i = 0; i \u0026lt; t_PMAlignTool1.Results.Count; i++) { for (int j = i + 1; j \u0026lt; t_PMAlignTool1.Results.Count; j++) { if (t_PMAlignResults[j].Score \u0026gt; t_PMAlignResults[i].Score) { t_PMAlignResult = t_PMAlignResults[i]; t_PMAlignResults[i] = t_PMAlignResults[j]; t_PMAlignResults[j] = t_PMAlignResult; } } } ","date":"2025-03-13T00:00:00Z","permalink":"https://zihui7896.github.io/p/visionpro-%E8%84%9A%E6%9C%AC/","title":"VisionPro 脚本"},{"content":"判断一张图片的RGB 是不是在范围内 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 // 判断一张图片的RGB 是不是在范围内 public bool CheckRGB(HObject image,int rMin, int rMax, int gMin, int gMax, int bMin, int bMax) { HObject red = null, green = null, blue = null; HObject redRegion = null, greenRegion = null, blueRegion = null; HObject tempRegion = null, validRegion = null; try { // 2. 检查是否为三通道图像 HTuple channels; HOperatorSet.CountChannels(image, out channels); if (channels.I != 3) throw new Exception(\u0026#34;错误：图像不是RGB三通道格式！\u0026#34;); // 3. 分解RGB通道 HOperatorSet.Decompose3(image, out red, out green, out blue); // 4. 对各通道进行阈值分割 HOperatorSet.Threshold(red, out redRegion, rMin, rMax); HOperatorSet.Threshold(green, out greenRegion, gMin, gMax); HOperatorSet.Threshold(blue, out blueRegion, bMin, bMax); // 5. 计算三个通道的交集 HOperatorSet.Intersection(redRegion, greenRegion, out tempRegion); HOperatorSet.Intersection(tempRegion, blueRegion, out validRegion); // 6. 计算有效区域像素数 HTuple areaValid, row, col; HOperatorSet.AreaCenter(validRegion, out areaValid, out row, out col); // 7. 获取总像素数 HTuple width, height; HOperatorSet.GetImageSize(image, out width, out height); long totalPixels = width * height; // 8. 判断结果 if (areaValid.L == totalPixels) { return true; } else { double ratio = (double)areaValid.D / totalPixels * 100; return false; } } catch (HalconException hex) { Console.WriteLine($\u0026#34;Halcon异常: {hex.Message}\u0026#34;); return false; } finally { // 释放所有Halcon对象 red.Dispose(); green.Dispose(); blue.Dispose(); redRegion.Dispose(); greenRegion.Dispose(); blueRegion.Dispose(); tempRegion.Dispose(); validRegion.Dispose(); } } ","date":"2025-03-12T00:00:00Z","permalink":"https://zihui7896.github.io/p/haclon-%E5%88%A4%E6%96%AD%E5%9B%BE%E7%89%87rgb/","title":"Haclon 判断图片RGB"},{"content":"串口通讯 16进制发 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 public void sendMsg(string msg) { if (serialPort.IsOpen) { byte[] data = HexStringToByteArray(msg); serialPort.Write(data, 0, data.Length); string s = string.Empty; for (int i = 0; i \u0026lt; data.Length; i ++) { s += data[i].ToString(); } // MachineException.CallException(ExceptionType.NormalInfo, \u0026#34;data\u0026#34;, s); } else { MessageBox.Show(\u0026#34;串口未打开\u0026#34;); } } public static byte[] HexStringToByteArray(string hex) { int length = hex.Length; if (length % 2 != 0) { throw new ArgumentException(\u0026#34;十六进制字符串长度必须为偶数。\u0026#34;); } byte[] bytes = new byte[length / 2]; for (int i = 0; i \u0026lt; length; i += 2) { string hexPair = hex.Substring(i, 2); bytes[i / 2] = Convert.ToByte(hexPair, 16); } return bytes; } 16进制收 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 string _Data = string.Empty; public void ReciveMsg(object sender, SerialDataReceivedEventArgs e) { SerialPort sp = (SerialPort)sender; // 读取字节数据 int bytesToRead = sp.BytesToRead; byte[] buffer = new byte[bytesToRead]; sp.Read(buffer, 0, bytesToRead); string hexData = BitConverter.ToString(buffer).Replace(\u0026#34;-\u0026#34;, \u0026#34;\u0026#34;); //010304024E00009B9C _Data += hexData; MachineException.CallException(ExceptionType.NormalInfo, \u0026#34;SerialPort Received Bytes\u0026#34;, _Data); // 检测结束符 if (_Data.StartsWith(\u0026#34;0103\u0026#34;) \u0026amp;\u0026amp; _Data.Length == 18) // 根据需要变 { MachineException.CallException(ExceptionType.NormalInfo, \u0026#34;_Data.EndsWith(\\\u0026#34;0103\\\u0026#34;) \u0026amp;\u0026amp; _Data.Length == 18\u0026#34;, _Data); GlobalVariable.eReciveData = _Data; string show = _Data; _Data = string.Empty; } } 发字符 1 2 3 4 5 6 7 8 9 10 11 12 public void sendMsg(string msg) { if (serialPort.IsOpen) { byte[] date = System.Text.Encoding.UTF8.GetBytes(msg); serialPort.Write(date, 0, date.Length); } else { MessageBox.Show(\u0026#34;串口未打开\u0026#34;); } } 接收字符 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 public void ReciveMsg(object sender, SerialDataReceivedEventArgs e) { SerialPort sp = (SerialPort)sender; string data = sp.ReadExisting(); //读取收到的数据 _Data += data; MachineException.CallException(ExceptionType.NormalInfo, \u0026#34;SerialPort sp.ReadExisting()\u0026#34;, _Data); if (_Data.EndsWith(\u0026#34;\\r\\n\u0026#34;)) { GlobalVariable.eReciveData = _Data; string show = data; //if (formProductMessage != null) //{ // formProductMessage.BeginInvoke(new Action(() =\u0026gt; // { // formProductMessage.rtb_showMsg.AppendText(show + \u0026#34;\\r\\n\u0026#34;); // })); //} _Data = string.Empty; } } public void ReciveMsg(object sender, SerialDataReceivedEventArgs e) { SerialPort sp = (SerialPort)sender; string data = sp.ReadExisting(); //读取收到的数据 _eData += data; if (_eData.EndsWith(\u0026#34;\\r\\n\u0026#34;)) { GlobalVariable.eReciveData = _电流Data; if (GlobalVariable.isShow) this.ProgramForm.formDebug.rtb_Recived.AppendText(_eData); _eData = string.Empty; } if (GlobalVariable.isShow) this.ProgramForm.formDebug.rtb_Recived.AppendText(data); //listReciveDate.Add(date); //Console.WriteLine(date); } PortCommunication.cs 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 using NBVision.Shared; using System; using System.Collections.Generic; using System.IO.Ports; using System.Linq; using System.Text; using System.Threading.Tasks; using System.Windows.Forms; using NBVision.UI.UserUI; using Nobug2.Vision; using Nobug; namespace NBVision.Flow { public class PortCommunication { public Action\u0026lt;string\u0026gt; laserMsgDisplay; public string Description; public SerialPort serialPort; public Action\u0026lt;string\u0026gt; myAction; public string Port { get; set; } public FormProductMessage formProduct; public List\u0026lt;string\u0026gt; listReciveDate = new List\u0026lt;string\u0026gt;(); public string _hex_order = \u0026#34;AA\u0026#34;; // 通讯命令 public bool isSignal = false; // 默认无信号 public PortCommunication(string description, string port = \u0026#34;COM5\u0026#34;, int baudRate = 9600, Parity parity = Parity.Even, int dataBits = 8, StopBits stopBits = StopBits.One) { this.Description = description; this.Port = port; serialPort = new SerialPort(); serialPort.PortName = port; serialPort.BaudRate = baudRate; serialPort.Parity = parity; serialPort.DataBits = dataBits; serialPort.StopBits = stopBits; serialPort.ReadTimeout = 2000; //serialPort.DataReceived += ReciveMsg; // 全局里面 } public bool Open() { try { if (serialPort != null) { if (!serialPort.IsOpen) { serialPort.Open(); } } return true; } catch (Exception ex) { // MachineException.CallException(ExceptionType.NormalErr, \u0026#34;\u0026#34;, ex.Message); MessageBox.Show(\u0026#34;测试仪器\u0026#34; + ex.Message); return false; } } public void CloseComPort() { if (serialPort != null) { if (serialPort.IsOpen) { serialPort.Close(); } } } } } ","date":"2025-03-05T00:00:00Z","permalink":"https://zihui7896.github.io/p/%E6%B3%B0%E5%9B%BD%E9%87%8D%E9%87%8F%E6%A3%80%E6%B5%8B/","title":"泰国重量检测"},{"content":" 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 #region xml 保存路径 private string xmlSavePath = @\u0026#34;D:\\\\Config.xml\u0026#34;; [Category(\u0026#34;XML保存路径\u0026#34;)] public string _xmlSavePath { get { return xmlSavePath; } set { xmlSavePath = value; } } #endregion public void Load() { try { Dictionary\u0026lt;string, string\u0026gt; dic = SerializeXmlSwitch.JsonDeserialize\u0026lt;Dictionary\u0026lt;string, string\u0026gt;\u0026gt;(SerializeXmlSwitch.DeserializeFromXml\u0026lt;String\u0026gt;(xmlSavePath)); _条码枪端口 = dic[\u0026#34;_条码枪端口\u0026#34;]; _检测仪器 = dic[\u0026#34;_检测仪器\u0026#34;]; _time_Interval = double.Parse(dic[\u0026#34;_time_Interval\u0026#34;]); _products_weight_Max = double.Parse(dic[\u0026#34;_products_weight_Max\u0026#34;]); _products_weight_Min = double.Parse(dic[\u0026#34;_products_weight_Min\u0026#34;]); } catch (Exception ex) { return; } } // 将值保存到指定文件内 public void Save(Dictionary\u0026lt;string, string\u0026gt; data) { if (!File.Exists(xmlSavePath)) { File.Create(xmlSavePath).Dispose(); } SerializeXmlSwitch.SerializeToXml(xmlSavePath, SerializeXmlSwitch.JsonSerializer(data)); } ","date":"2025-03-05T00:00:00Z","permalink":"https://zihui7896.github.io/p/%E5%BA%8F%E5%88%97%E5%8C%96%E5%AD%97%E5%85%B8/","title":"序列化字典"},{"content":" 1 2 3 4 5 6 7 8 this.Invoke()的作用与用法、不阻塞UI界面线程的延时函数 Invoke 与begininvoke区别在于，invoke会阻塞当前线程，直到invoke调用结束，才会继续执行下去，而begininvoke 则可以异步进行调用，也就是该方法封送完毕后马上返回，不会等待委托方法的执行结束，调用者线程将不会被阻塞。但是调用者也可以使用EndInvoke方法或者其它类似 WaitHandle机制等待异步操作的完成。 如果你的后台线程在更新一个UI控件的状态后不需要等待，而是要继续往下处理，那么你就应该使用BeginInvoke来进行异步处理。 如果你的后台线程需要操作UI控件，并且需要等到该操作执行完毕才能继续执行，那么你就应该使用Invoke。 EventHandler即事件委托，表示用于处理不具有事件数据的事件的方法。 代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 this._formMain.UserUIForm.formProductMessage.BeginInvoke(new Action(() =\u0026gt; { this._formMain.UserUIForm.formProductMessage.lb_90_2Code.Text = _programDate.Load; this._formMain.UserUIForm.formProductMessage.lb_90_2Code2.Text = _programDate.UnLoad; this._formMain.UserUIForm.formProductMessage.lb_90_2CodeResult.Text = \u0026#34;1\u0026#34;; this._formMain.UserUIForm.formProductMessage.lb_90_2CodeResult2.Text = \u0026#34;1\u0026#34;; })); this.BeginInvoke(new Action(() =\u0026gt; { this.weight_label.Text = s; })); this.formMain.UserUIForm.BeginInvoke(new Action(() =\u0026gt; { formMain.UserUIForm.formProductMessage.btn_status.Text = \u0026#34;相机处理中...\u0026#34;; formMain.UserUIForm.formProductMessage.btn_status.BackColor = System.Drawing.Color.White; })); ","date":"2025-03-03T00:00:00Z","permalink":"https://zihui7896.github.io/p/c%23%E5%BC%82%E6%AD%A5begininoke/","title":"C#异步BeginInoke"},{"content":" 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 public void SaveCsv1(float weight_value, string StartTime, string path) { string Data = string.Empty; Data += weight_value + \u0026#34;,\u0026#34;; Data += StartTime; if (!Directory.Exists(path)) { Directory.CreateDirectory(path); } string filepath = path + \u0026#34;\\\\\u0026#34; + DateTime.Now.ToString(\u0026#34;yyyy-MM-dd HH:mm:ss\u0026#34;) + \u0026#34;.csv\u0026#34;; if (!File.Exists(filepath)) { File.Create(filepath).Dispose(); using (StreamWriter sw = new StreamWriter(filepath, true)) { sw.WriteLine(\u0026#34;Weight\u0026#34; + \u0026#34;,\u0026#34; + \u0026#34;Time\u0026#34;); // 第一行 sw.Close(); } } using (StreamWriter sw = new StreamWriter(filepath, true)) // 追加数据 { sw.WriteLine(Data); // 内容 sw.Close(); } //using (StreamWriter sw = new StreamWriter(filepath, false)) // 不追加数据 //{ // sw.WriteLine(Data); // sw.Close(); //} } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 CSV1(DateTime.Now.ToString(\u0026#34;HH:mm:ss\u0026#34;) + \u0026#34;,\u0026#34; + Data_Str1 + l, @\u0026#34;E:\\\\Data\\\\Cam1\\\\第一段\\\\Up_Data\u0026#34;); #region 保存数据1 string Data_Name1; public void CSV1(string Data, string path) { int Long_Caliper_Count = (int) mToolBlock.Inputs[\u0026#34;Long_Caliper_Count\u0026#34;].Value; //int Short_Caliper_Count = (int) mToolBlock.Inputs[\u0026#34;Short_Caliper_Count\u0026#34;].Value; if (!Directory.Exists(path)) { Directory.CreateDirectory(path); } string filepath = path + \u0026#34;\\\\\u0026#34; + DateTime.Now.ToString(\u0026#34;yyyyMMdd\u0026#34;) + \u0026#34;.csv\u0026#34;; if (!File.Exists(filepath)) { File.Create(filepath).Dispose(); using (StreamWriter sw = new StreamWriter(filepath, true)) { for (int i = 0; i \u0026lt; Long_Caliper_Count; i++) { Data_Name1 += \u0026#34;Distance\u0026#34; + (i + 1) + \u0026#34;,\u0026#34;; } sw.WriteLine(\u0026#34;Time,\u0026#34; + Data_Name1 + \u0026#34;,Result\u0026#34;); sw.Close(); } } using (StreamWriter sw = new StreamWriter(filepath, true)) { sw.WriteLine(Data); sw.Close(); } } #endregion ","date":"2025-02-14T00:00:00Z","permalink":"https://zihui7896.github.io/p/%E4%BF%9D%E5%AD%98csv%E6%96%87%E4%BB%B6/","title":"保存csv文件"},{"content":"FHS17 定位引导贴绝缘罩 宜宾线 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 public PackLineSiemensS7ControlCom.OffsetReturnsParameters TriggerOffset1(PackLineSiemensS7ControlCom.TriggerOffsetParameter triggerOffsetParameter) { PackLineSiemensS7ControlCom.OffsetReturnsParameters t_OffsetReturnsParameters = new PackLineSiemensS7ControlCom.OffsetReturnsParameters(); #region 偏移计算 int t_IndexCamera = triggerOffsetParameter.triggerParameter.IndexCamera; if (t_IndexCamera == 3 \u0026amp;\u0026amp; triggerOffsetParameter.triggerParameter.IndexTakePhoto\u0026gt;0\u0026amp;\u0026amp; triggerOffsetParameter.triggerParameter.IndexTakePhoto\u0026lt;6)// (triggerOffsetParameter.triggerParameter.CalibrationType == 1 || triggerOffsetParameter.triggerParameter.CalibrationType == 2)) { t_PalaceTriggerOffset(triggerOffsetParameter, ref t_OffsetReturnsParameters); } else if ((triggerOffsetParameter.triggerParameter.ProgramNumber == 5) || (triggerOffsetParameter.triggerParameter.ProgramNumber == 4)) // 拍照序号 6 以上 （7） { if ((triggerOffsetParameter.triggerParameter.IndexCamera == 3)) { CCD1Mark基准(triggerOffsetParameter, ref t_OffsetReturnsParameters); } else { m_App.m_Log.WriteLog(Log.LevelEnum.error, \u0026#34;校验相机号错误\u0026#34;); } } else { m_App.m_Log.WriteLog(Log.LevelEnum.error, \u0026#34;不包含此种模式\u0026#34;); } #endregion return t_OffsetReturnsParameters; } public void t_PalaceTriggerOffset(PackLineSiemensS7ControlCom.TriggerOffsetParameter triggerOffsetParameter, ref PackLineSiemensS7ControlCom.OffsetReturnsParameters offsetReturnsParameters) { offsetReturnsParameters.Result = false; int t_IndexCamera = triggerOffsetParameter.triggerParameter.IndexCamera; //程序号 int t_ProgramNumber = triggerOffsetParameter.triggerParameter.ProgramNumber; //不同模组 int t_IndexTakePhoto = triggerOffsetParameter.triggerParameter.IndexTakePhoto; int t_CalibrationType = triggerOffsetParameter.triggerParameter.CalibrationType; string Code = triggerOffsetParameter.triggerParameter.ModelCode; double t_CurrentX = triggerOffsetParameter.coordinateParameter.X; double t_CurrentY = triggerOffsetParameter.coordinateParameter.Y; double t_CurrentRZ = triggerOffsetParameter.coordinateParameter.A; t_CurrentX = 572.39; t_CurrentY = -1184.89; t_CurrentRZ = -147.39; double t_OffsetX = 99; double t_OffsetY = 99; //double t_OffsetR = 99; double t_TrainX=0, t_TrainY=0, t_TrainRZ=0; offsetReturnsParameters.coordinateParameter.X = 99; offsetReturnsParameters.coordinateParameter.Y = 99; //offsetReturnsParameters.coordinateParameter.A = 99; offsetReturnsParameters.PhotoResult = new bool[1] { false }; if (t_IndexCamera != 3) { m_App.m_Log.WriteLog(Log.LevelEnum.error, \u0026#34;抓取偏移计算 相机序号错误！\u0026#34;); return; } //if (t_CalibrationType != 1) //{ // m_App.m_Log.WriteLog(Log.LevelEnum.error, \u0026#34;抓取偏移计算 标定类型错误！\u0026#34;); // return; //} t_IndexCamera = t_IndexCamera; if (t_ProgramNumber == 2) { if (!引导示教ToolStripMenuItem.Checked) { MessageBox.Show(\u0026#34;相机未勾选示教！\u0026#34;); return; } //放料训练示教 m_App.m_RecipeINI.WritePoint(\u0026#34;CCD\u0026#34;+t_IndexCamera.ToString()+\u0026#34;RobotPutPoint\u0026#34; + t_IndexTakePhoto.ToString(), t_CurrentX, t_CurrentY, t_CurrentRZ); } CogToolBlock t_CogToolBlocks = m_App.m_RecipeCogToolBlock[t_IndexCamera]; string t_FunctionToolName = \u0026#34;Function_\u0026#34; + t_IndexTakePhoto.ToString(); if (!t_CogToolBlocks.Tools.Contains(t_FunctionToolName)) { m_App.m_Log.WriteLog(Log.LevelEnum.error, \u0026#34;ToolBlock\u0026#34; + t_IndexCamera.ToString() + \u0026#34;不含功能工具 \u0026#34; + t_FunctionToolName); return; } CogToolBlock t_FunctionCogToolBlock = (CogToolBlock)t_CogToolBlocks.Tools[t_FunctionToolName]; string t_CalibToolName = \u0026#34;Calib\u0026#34;; if (!t_FunctionCogToolBlock.Tools.Contains(t_CalibToolName)) { m_App.m_Log.WriteLog(Log.LevelEnum.error, \u0026#34;ToolBlock\u0026#34; + t_IndexCamera.ToString() + \u0026#34;不含标定工具 \u0026#34; + t_CalibToolName); return; } string t_FindMarkToolName = \u0026#34;FindMarkPoint\u0026#34;; if (!t_FunctionCogToolBlock.Tools.Contains(t_FindMarkToolName)) { m_App.m_Log.WriteLog(Log.LevelEnum.error, \u0026#34;ToolBlock\u0026#34; + t_IndexCamera.ToString() + \u0026#34;不含FindMarkPoint工具 \u0026#34; + t_FindMarkToolName); return; } CogToolBlock t_CalibCogToolBlock = (CogToolBlock)t_FunctionCogToolBlock.Tools[t_CalibToolName]; CogToolBlock t_FindMarkCogToolBlock = (CogToolBlock)t_FunctionCogToolBlock.Tools[t_FindMarkToolName]; double t_FindMarkExposure = (double)t_FindMarkCogToolBlock.Inputs[\u0026#34;Exposure\u0026#34;].Value; ICogImage t_CogImage = m_App.m_ICameras[t_IndexCamera].Acquire(t_FindMarkExposure);//TEST Display_Clear(m_DisplayExs[t_IndexCamera].cogRecordDisplay1); m_DisplayExs[t_IndexCamera].cogRecordDisplay1.Image = t_CogImage; t_CalibCogToolBlock.Inputs[\u0026#34;InputImage\u0026#34;].Value = t_CogImage; t_CalibCogToolBlock.Inputs[\u0026#34;RunMode\u0026#34;].Value = \u0026#34;Run\u0026#34;; t_CalibCogToolBlock.Inputs[\u0026#34;CurrentX\u0026#34;].Value = t_CurrentX; t_CalibCogToolBlock.Inputs[\u0026#34;CurrentY\u0026#34;].Value = t_CurrentY; t_CalibCogToolBlock.Inputs[\u0026#34;CurrentRZ\u0026#34;].Value = t_CurrentRZ; t_CalibCogToolBlock.Run(); if (t_CalibCogToolBlock.RunStatus.Result != CogToolResultConstants.Accept) { m_App.m_Log.WriteLog(Log.LevelEnum.error, \u0026#34;相机：\u0026#34; + t_IndexCamera.ToString() + \u0026#34;标定工具：计算运行异常！\u0026#34;); return; } ICogImage t_CalibCogImage = (ICogImage)t_CalibCogToolBlock.Outputs[\u0026#34;OutputImage\u0026#34;].Value; t_FindMarkCogToolBlock.Inputs[\u0026#34;InputImage\u0026#34;].Value = t_CalibCogImage; t_FindMarkCogToolBlock.Run(); if (t_FindMarkCogToolBlock.RunStatus.Result != CogToolResultConstants.Accept) { m_App.m_Log.WriteLog(Log.LevelEnum.error, \u0026#34;相机：\u0026#34; + t_IndexCamera.ToString() + \u0026#34;FindMark工具： \u0026#34; + \u0026#34;运行异常，请检查！\u0026#34;); return; } m_App.m_Log.WriteLog(Log.LevelEnum.normal, \u0026#34;相机：\u0026#34; + t_IndexCamera.ToString() + \u0026#34;FindMark工具 搜索成功！\u0026#34;); ///增加画图 var m_ICogRecord = t_FindMarkCogToolBlock.CreateLastRunRecord().SubRecords[0]; m_DisplayExs[t_IndexCamera].cogRecordDisplay1.Record = m_ICogRecord; CogTransform2DLinear t_CurrentTransform2DLinear = (CogTransform2DLinear)t_FindMarkCogToolBlock.Outputs[\u0026#34;Transform2DLinear\u0026#34;].Value; if (t_ProgramNumber == 1) { if (!引导示教ToolStripMenuItem.Checked) { MessageBox.Show(\u0026#34;相机未勾选示教！\u0026#34;); return; } //视觉训练示教 t_TrainX= (double)t_FindMarkCogToolBlock.Outputs[\u0026#34;Result_X\u0026#34;].Value; t_TrainY = (double)t_FindMarkCogToolBlock.Outputs[\u0026#34;Result_Y\u0026#34;].Value; t_TrainRZ = (double)t_FindMarkCogToolBlock.Outputs[\u0026#34;Result_Rotation\u0026#34;].Value; m_App.m_RecipeINI.WritePoint(\u0026#34;CCD\u0026#34; + t_IndexCamera.ToString() + \u0026#34;Train\u0026#34; + t_IndexTakePhoto.ToString(), t_TrainX, t_TrainY, t_TrainRZ); t_FindMarkCogToolBlock.Inputs[\u0026#34;TrainTransform2DLinear\u0026#34;].Value = t_CurrentTransform2DLinear; m_App.SaveRecipeToolBlock(t_IndexCamera);//保存 } else if (t_ProgramNumber == 2) { if (!引导示教ToolStripMenuItem.Checked) { MessageBox.Show(\u0026#34;相机未勾选示教！\u0026#34;); return; } //放料训练示教 m_App.m_RecipeINI.WritePoint(\u0026#34;CCD\u0026#34; + t_IndexCamera.ToString() + \u0026#34;RobotPutPoint\u0026#34; + t_IndexTakePhoto.ToString(), t_CurrentX, t_CurrentY, t_CurrentRZ); } else if (t_ProgramNumber == 3) { //引导安装 CogTransform2DLinear t_TrainTransform2DLinear = (CogTransform2DLinear)t_FindMarkCogToolBlock.Inputs[\u0026#34;TrainTransform2DLinear\u0026#34;].Value; m_App.m_RecipeINI.ReadPoint(\u0026#34;CCD\u0026#34; + t_IndexCamera.ToString() + \u0026#34;Train\u0026#34; + t_IndexTakePhoto.ToString(),out t_TrainX, out t_TrainY, out t_TrainRZ); double CurrentX = (double)t_FindMarkCogToolBlock.Outputs[\u0026#34;Result_X\u0026#34;].Value; double CurrentY = (double)t_FindMarkCogToolBlock.Outputs[\u0026#34;Result_Y\u0026#34;].Value; m_App.m_Log.WriteLog(Log.LevelEnum.normal, \u0026#34;当前Mark11X: \u0026#34; + CurrentX.ToString(\u0026#34;0.00\u0026#34;)); m_App.m_Log.WriteLog(Log.LevelEnum.normal, \u0026#34;当前Mark11Y: \u0026#34; + CurrentY.ToString(\u0026#34;0.00\u0026#34;)); m_App.m_Log.WriteLog(Log.LevelEnum.normal, \u0026#34;示教Mark11X: \u0026#34; + t_TrainX.ToString(\u0026#34;0.00\u0026#34;)); m_App.m_Log.WriteLog(Log.LevelEnum.normal, \u0026#34;示教Mark11Y: \u0026#34; + t_TrainY.ToString(\u0026#34;0.00\u0026#34;)); //读取机器人示教贴绝缘罩的位置 // m_App.m_RecipeINI.ReadPoint(\u0026#34;CCD\u0026#34; + t_IndexCamera.ToString() + \u0026#34;RobotPutPoint\u0026#34; + t_IndexTakePhoto.ToString(), out double t_X, out double t_Y, out double t_R); //string t_FindTwoPointPoseName = \u0026#34;FindTwoPointPose\u0026#34;; //if (!t_FunctionCogToolBlock.Tools.Contains(t_FindTwoPointPoseName)) //{ // m_App.m_Log.WriteLog(Log.LevelEnum.error, \u0026#34;ToolBlock\u0026#34; + t_IndexCamera.ToString() + \u0026#34;不含FindTwoPointPose工具 \u0026#34; + t_FindTwoPointPoseName); // return ; //} //CogToolBlock t_FindTwoPointPose = (CogToolBlock)t_FunctionCogToolBlock.Tools[t_FindTwoPointPoseName]; //t_FindTwoPointPose.Inputs[\u0026#34;InputImage\u0026#34;].Value = t_CalibCogImage; //t_FindTwoPointPose.Inputs[\u0026#34;TrainX1\u0026#34;].Value = t_TrainX; //t_FindTwoPointPose.Inputs[\u0026#34;TrainY1\u0026#34;].Value = t_TrainY; //t_FindTwoPointPose.Inputs[\u0026#34;CurrentX1\u0026#34;].Value = (double)t_FindMarkCogToolBlock.Outputs[\u0026#34;Result_X\u0026#34;].Value; //t_FindTwoPointPose.Inputs[\u0026#34;CurrentY1\u0026#34;].Value = (double)t_FindMarkCogToolBlock.Outputs[\u0026#34;Result_Y\u0026#34;].Value; //t_FindTwoPointPose.Run(); //CogTransform2DLinear t_CogTransform2DLinear = (CogTransform2DLinear)t_FindTwoPointPose.Outputs[\u0026#34;OutputTransform2D\u0026#34;].Value; #region 贴合位坐标转换到示教点坐标系，再通过当前点坐标系转换回来，再减去贴合位坐标就是偏差值 //将以机械手原点为原点的坐标系的机械手贴合示教位坐标转换为以相机示教点为原点的坐标系的坐标 //t_TrainTransform2DLinear.Invert().MapPoint(t_X, t_Y, out double t_X1, out double t_Y1); //将以相机当前Mark点为原点为原点的坐标系的机械手贴合示教位坐标转换为以相机示教点为原点的坐标系的坐标 //t_CurrentTransform2DLinear.MapPoint(t_X1, t_Y1, out double t_X2, out double t_Y2); #endregion //t_CogTransform2DLinear.MapPoint(t_X, t_Y, out double t_X2, out double t_Y2); t_OffsetY =CurrentX -t_TrainX ;//机器人和标定姿态不一致导致XY与标定时两轴相反 t_OffsetX = CurrentY- t_TrainY ; //t_OffsetR = (t_CurrentTransform2DLinear.Rotation - t_TrainTransform2DLinear.Rotation) / Math.PI * 180.0; offsetReturnsParameters.coordinateParameter.X = (float)t_OffsetX; offsetReturnsParameters.coordinateParameter.Y = (float)t_OffsetY; //offsetReturnsParameters.coordinateParameter.A = (float)t_OffsetR; m_App.m_Log.WriteLog(Log.LevelEnum.normal, \u0026#34;计算结果 OffsetX: \u0026#34; + t_OffsetX.ToString(\u0026#34;0.00\u0026#34;)); m_App.m_Log.WriteLog(Log.LevelEnum.normal, \u0026#34;计算结果 OffsetY: \u0026#34; + t_OffsetY.ToString(\u0026#34;0.00\u0026#34;)); //m_App.m_Log.WriteLog(Log.LevelEnum.normal, \u0026#34;计算结果 OffsetR: \u0026#34; + t_OffsetR.ToString(\u0026#34;0.00\u0026#34;)); bool t_Result = false; m_App.m_SystemINI.ReadPoint(\u0026#34;Offset_Max\u0026#34;, out double t_OffsetX_Max, out double t_OffsetY_Max, out double t_OffsetR_Max); if (Math.Abs(t_OffsetX) \u0026lt; t_OffsetX_Max \u0026amp;\u0026amp; Math.Abs(t_OffsetY) \u0026lt; t_OffsetY_Max+10) { m_App.m_Log.WriteLog(Log.LevelEnum.normal, \u0026#34;补偿计算OK\u0026#34;); t_Result = true; } else { m_App.m_Log.WriteLog(Log.LevelEnum.error, \u0026#34;补偿超限：\u0026#34; + \u0026#34;运行异常，请检查！\u0026#34;); t_Result = false; } offsetReturnsParameters.PhotoResult[0] = t_Result; offsetReturnsParameters.Result = t_Result; m_App.m_SaveImage.Save_SourceImage(t_CogImage, t_Result, Code, true, \u0026#34;CCD\u0026#34; + t_IndexCamera.ToString(), true, \u0026#34;端板安装引导\u0026#34;, true);//原图保存 } else { m_App.m_Log.WriteLog(Log.LevelEnum.error, \u0026#34;程序号错误！\u0026#34;); return; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 #region namespace imports using System; using System.Collections; using System.Drawing; using System.IO; using System.Windows.Forms; using Cognex.VisionPro; using Cognex.VisionPro.ToolBlock; using Cognex.VisionPro3D; using Cognex.VisionPro.CalibFix; using Cognex.VisionPro.ImageProcessing; #endregion public class CogToolBlockAdvancedScript : CogToolBlockAdvancedScriptBase { #region Private Member Variables private Cognex.VisionPro.ToolBlock.CogToolBlock mToolBlock; private CogGraphicCollection m_GraphicCollection ; private double m_ux = 0; private double m_uy = 0; private double m_ur = 0; #endregion /// \u0026lt;summary\u0026gt; /// Called when the parent tool is run. /// Add code here to customize or replace the normal run behavior. /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;message\u0026#34;\u0026gt;Sets the Message in the tool\u0026#39;s RunStatus.\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;result\u0026#34;\u0026gt;Sets the Result in the tool\u0026#39;s RunStatus\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;True if the tool should run normally, /// False if GroupRun customizes run behavior\u0026lt;/returns\u0026gt; public override bool GroupRun(ref string message, ref CogToolResultConstants result) { // To let the execution stop in this script when a debugger is attached, uncomment the following lines. // #if DEBUG // if (System.Diagnostics.Debugger.IsAttached) System.Diagnostics.Debugger.Break(); // #endif // Run each tool using the RunTool function //foreach(ICogTool tool in mToolBlock.Tools) //mToolBlock.RunTool(tool, ref message, ref result); //显示状态集 if(m_GraphicCollection == null) { m_GraphicCollection = new CogGraphicCollection(); } else { m_GraphicCollection.Clear(); } result = CogToolResultConstants.Error; //状态显示标签 CogGraphicLabel t_Label = new CogGraphicLabel(); //左对齐 t_Label.Alignment = CogGraphicLabelAlignmentConstants.BaselineLeft; //字体 t_Label.Font = new Font(\u0026#34;ss\u0026#34;, 18); //显示颜色 t_Label.Color = CogColorConstants.Green; //显示空间 t_Label.SelectedSpaceName = \u0026#34;#\u0026#34;; Cognex.VisionPro.CogImage24PlanarColor t_InputImage1 = (Cognex.VisionPro.CogImage24PlanarColor) mToolBlock.Inputs[\u0026#34;InputImage\u0026#34;].Value; CogImageConvertTool t_CogImageConvertTool1 = (CogImageConvertTool) mToolBlock.Tools[\u0026#34;CogImageConvertTool1\u0026#34;]; t_CogImageConvertTool1.InputImage = t_InputImage1; t_CogImageConvertTool1.Run(); Cognex.VisionPro.CogImage8Grey t_InputImage = (CogImage8Grey) t_CogImageConvertTool1.OutputImage; //以图像中心为计算目标，图像中心畸变最小 double zx = t_InputImage.Width / 2; double zy = t_InputImage.Height / 2; double ux = 0; double uy = 0; //RunMode 运行模式 Calib:Run string t_RunMode = (string) mToolBlock.Inputs[\u0026#34;RunMode\u0026#34;].Value; //InverseRz RZ旋转方向取反 //移动机构为标准机器人时一般情况为False,不需要取反 //移动机构为行架时，需要根据实际情况，可能需要进行取反 bool t_InverseRz=(bool)mToolBlock.Inputs[\u0026#34;InverseRz\u0026#34;].Value; int t_InverseRzInt = t_InverseRz ? -1 : 1; //CheckerboardMove 标定时标定板移动，默认情况下False,标定板固定，相机移动 //True,标定板移动，相机固定 bool t_CheckerboardMove=(bool)mToolBlock.Inputs[\u0026#34;CheckerboardMove\u0026#34;].Value; int t_CheckerboardMoveInt = t_CheckerboardMove ? -1 : 1; CogCalibCheckerboardTool t_CheckerboardTool1 = (CogCalibCheckerboardTool) mToolBlock.Tools[\u0026#34;CogCalibCheckerboardTool1\u0026#34;]; CogCalibCheckerboardTool t_CheckerboardTool2 = (CogCalibCheckerboardTool) mToolBlock.Tools[\u0026#34;CogCalibCheckerboardTool2\u0026#34;]; CogCalibNPointToNPointTool t_NPointToNPointTool1 = (CogCalibNPointToNPointTool) mToolBlock.Tools[\u0026#34;CogCalibNPointToNPointTool1\u0026#34;]; CogFixtureTool t_FixtureTool1 = (CogFixtureTool) mToolBlock.Tools[\u0026#34;CogFixtureTool1\u0026#34;]; CogFixtureTool t_FixtureTool2 = (CogFixtureTool) mToolBlock.Tools[\u0026#34;CogFixtureTool2\u0026#34;]; double t_CurrentX = (double) mToolBlock.Inputs[\u0026#34;CurrentX\u0026#34;].Value * t_CheckerboardMoveInt; double t_CurrentY = (double) mToolBlock.Inputs[\u0026#34;CurrentY\u0026#34;].Value * t_CheckerboardMoveInt; double t_CurrentRZ = (double) mToolBlock.Inputs[\u0026#34;CurrentRZ\u0026#34;].Value; if (t_RunMode == \u0026#34;Calib\u0026#34;) { // 1; 当前标定序号 int t_CalibIndexint = (int) mToolBlock.Inputs[\u0026#34;CalibIndex\u0026#34;].Value; try { if(t_CalibIndexint == 1) { #region 9点第一点 //初始化标定 while (t_NPointToNPointTool1.Calibration.NumPoints != 0) { t_NPointToNPointTool1.Calibration.DeletePointPair(0); } t_CheckerboardTool1.InputImage = t_InputImage; t_CheckerboardTool1.Calibration.CalibrationImage = t_CheckerboardTool1.InputImage; t_CheckerboardTool1.Calibration.Calibrate(); t_CheckerboardTool1.Run(); if (t_CheckerboardTool1.RunStatus.Result != CogToolResultConstants.Accept) { result = t_CheckerboardTool1.RunStatus.Result; message = \u0026#34;CheckerboardTool1 Run ERROR\u0026#34;; return false; } t_Label.SetXYText(200, 300, \u0026#34;NP\u0026#34; + t_CalibIndexint.ToString() + \u0026#34;平移特征点抓取成功！\u0026#34;); m_GraphicCollection.Add(t_Label.Copy(CogCopyShapeConstants.All)); ICogTransform2D t_Transform2D1 = t_CheckerboardTool1.OutputImage.GetTransform(@\u0026#34;@\\Checkerboard Calibration1\u0026#34;, \u0026#34;@\u0026#34;) as ICogTransform2D; t_Transform2D1.MapPoint(zx, zy, out ux, out uy); t_NPointToNPointTool1.Calibration.AddPointPair(ux, uy, t_CurrentX, t_CurrentY); mToolBlock.Inputs[\u0026#34;CalibX\u0026#34;].Value = t_CurrentX * t_CheckerboardMoveInt; mToolBlock.Inputs[\u0026#34;CalibY\u0026#34;].Value = t_CurrentY * t_CheckerboardMoveInt; mToolBlock.Inputs[\u0026#34;CalibRZ\u0026#34;].Value = t_CurrentRZ; result = CogToolResultConstants.Accept; return false; #endregion } if((t_CalibIndexint \u0026gt; 1 \u0026amp;\u0026amp; t_CalibIndexint \u0026lt; 10)) { t_CheckerboardTool2.InputImage = t_InputImage; t_CheckerboardTool2.Calibration.CalibrationImage = t_CheckerboardTool2.InputImage; t_CheckerboardTool2.Calibration.Calibrate(); t_CheckerboardTool2.Run(); if (t_CheckerboardTool2.RunStatus.Result != CogToolResultConstants.Accept) { result = t_CheckerboardTool2.RunStatus.Result; message = \u0026#34;CheckerboardTool2 Run ERROR\u0026#34;; return false; } t_Label.SetXYText(200, 300, \u0026#34;NP\u0026#34; + t_CalibIndexint.ToString() + \u0026#34;平移特征点抓取成功！\u0026#34;); m_GraphicCollection.Add(t_Label.Copy(CogCopyShapeConstants.All)); ICogTransform2D t_Transform2D1 = t_CheckerboardTool2.OutputImage.GetTransform(@\u0026#34;@\\Checkerboard Calibration2\u0026#34;, \u0026#34;@\u0026#34;) as ICogTransform2D; t_Transform2D1.MapPoint(zx, zy, out ux, out uy); t_NPointToNPointTool1.Calibration.AddPointPair(ux, uy, t_CurrentX, t_CurrentY); if(t_CalibIndexint == 9) { //第9点对NP工具进行标定 t_NPointToNPointTool1.InputImage = t_CheckerboardTool1.OutputImage; t_NPointToNPointTool1.CalibrationImage = t_NPointToNPointTool1.InputImage; t_NPointToNPointTool1.Calibration.Calibrate(); t_NPointToNPointTool1.Run(); if (t_NPointToNPointTool1.RunStatus.Result != CogToolResultConstants.Accept) { result = t_NPointToNPointTool1.RunStatus.Result; message = \u0026#34;NPointToNPointTool1 Run ERROR\u0026#34;; return false; } t_Label.SetXYText(400, 300, \u0026#34;NP 畸变误差\u0026#34; + t_NPointToNPointTool1.Calibration.ComputedRMSError.ToString(\u0026#34;f3\u0026#34;)); m_GraphicCollection.Add(t_Label.Copy(CogCopyShapeConstants.All)); } result = CogToolResultConstants.Accept; } if( t_CalibIndexint \u0026gt; 9 \u0026amp;\u0026amp; t_CalibIndexint \u0026lt; 12) { t_CheckerboardTool2.InputImage = t_InputImage; t_CheckerboardTool2.Calibration.CalibrationImage = t_CheckerboardTool2.InputImage; t_CheckerboardTool2.Calibration.Calibrate(); t_CheckerboardTool2.Run(); if (t_CheckerboardTool2.RunStatus.Result != CogToolResultConstants.Accept) { result = t_CheckerboardTool2.RunStatus.Result; message = \u0026#34;CheckerboardTool2 Run ERROR\u0026#34;; return false; } t_Label.SetXYText(200, 300, \u0026#34;NP\u0026#34; + t_CalibIndexint.ToString() + \u0026#34;旋转特征点抓取成功！\u0026#34;); m_GraphicCollection.Add(t_Label.Copy(CogCopyShapeConstants.All)); double t_ux,t_uy; ICogTransform2D t_Transform2D1 = t_CheckerboardTool2.OutputImage.GetTransform(@\u0026#34;@\\Checkerboard Calibration2\u0026#34;, \u0026#34;@\u0026#34;) as ICogTransform2D; t_Transform2D1.MapPoint(zx, zy, out t_ux, out t_uy); ICogTransform2D t_Transform2D2 = (ICogTransform2D) t_NPointToNPointTool1.OutputImage.GetTransform(@\u0026#34;@\\Checkerboard Calibration1\\N-Point Calibration1\u0026#34;, @\u0026#34;@\\Checkerboard Calibration1\u0026#34;); t_Transform2D2.MapPoint(t_ux, t_uy, out ux, out uy); if(t_CalibIndexint == 10) { m_ux = ux; m_uy = uy; m_ur = t_CurrentRZ; result = CogToolResultConstants.Accept; } else if(t_CalibIndexint == 11) { double t_x1,t_y1,t_r1,t_x2,t_y2,t_r2; t_x1 = m_ux; t_y1 = m_uy; t_r1 = m_ur; t_x2 = ux; t_y2 = uy; t_r2 = t_CurrentRZ; double t_r = (t_r2 - t_r1) * t_InverseRzInt; double angle = Math.PI * t_r / 180; double CenterX = ((t_x1 + t_x2) / 2) + ((t_y1 - t_y2) / 2) * (Math.Sin(angle) / (1 - Math.Cos(angle))); double CenterY = ((t_y1 + t_y2) / 2) - ((t_x1 - t_x2) / 2) * (Math.Sin(angle) / (1 - Math.Cos(angle))); CogTransform2DLinear t_CogTransform2DLinear = (CogTransform2DLinear) t_FixtureTool1.RunParams.UnfixturedFromFixturedTransform; t_CogTransform2DLinear.TranslationX = CenterX; t_CogTransform2DLinear.TranslationY = CenterY; t_CogTransform2DLinear.Rotation = 0; t_FixtureTool1.RunParams.UnfixturedFromFixturedTransform = t_CogTransform2DLinear; t_FixtureTool1.InputImage = t_NPointToNPointTool1.OutputImage; t_FixtureTool1.Run(); if (t_FixtureTool1.RunStatus.Result != CogToolResultConstants.Accept) { result = t_FixtureTool1.RunStatus.Result; message = \u0026#34;FixtureTool1 Run ERROR\u0026#34;; return false; } t_Label.SetXYText(400, 300, \u0026#34;NP\u0026#34; + t_CalibIndexint.ToString() + \u0026#34;旋转中心标定成功！\u0026#34;); m_GraphicCollection.Add(t_Label.Copy(CogCopyShapeConstants.All)); result = CogToolResultConstants.Accept; } } } catch (Exception e) { result = CogToolResultConstants.Error; message = e.Message; t_Label.SetXYText(600, 300, \u0026#34;标定板特征点抓取失败，请重新矫正,标定点：\u0026#34; + t_CalibIndexint.ToString() + \u0026#34; \u0026#34; + e.Message); m_GraphicCollection.Add(t_Label.Copy(CogCopyShapeConstants.All)); } } else if(t_RunMode == \u0026#34;Run\u0026#34;) { #region 运行 t_CheckerboardTool1.InputImage = t_InputImage; t_CheckerboardTool1.Run(); if (t_CheckerboardTool1.RunStatus.Result != CogToolResultConstants.Accept) { result = t_CheckerboardTool1.RunStatus.Result; message = \u0026#34;CheckerboardTool1 Run ERROR\u0026#34;; return false; } t_NPointToNPointTool1.InputImage = t_CheckerboardTool1.OutputImage; t_NPointToNPointTool1.Run(); if (t_NPointToNPointTool1.RunStatus.Result != CogToolResultConstants.Accept) { result = t_NPointToNPointTool1.RunStatus.Result; message = \u0026#34;NPointToNPointTool1 Run ERROR\u0026#34;; return false; } mToolBlock.Outputs[\u0026#34;OutputImage\u0026#34;].Value =t_NPointToNPointTool1.OutputImage; t_FixtureTool1.InputImage = t_NPointToNPointTool1.OutputImage; CogTransform2DLinear t_CogTransform2DLinear1 = (CogTransform2DLinear) t_FixtureTool1.RunParams.UnfixturedFromFixturedTransform; double t_CalibRZ = (double) mToolBlock.Inputs[\u0026#34;CalibRZ\u0026#34;].Value; t_CogTransform2DLinear1.Rotation = (t_CalibRZ - t_CurrentRZ) / 180 * Math.PI;; t_FixtureTool1.RunParams.UnfixturedFromFixturedTransform = t_CogTransform2DLinear1; t_FixtureTool1.Run(); if (t_FixtureTool1.RunStatus.Result != CogToolResultConstants.Accept) { result = t_FixtureTool1.RunStatus.Result; message = \u0026#34;FixtureTool1 Run ERROR\u0026#34;; return false; } t_FixtureTool2.InputImage = t_FixtureTool1.OutputImage; CogTransform2DLinear t_CogTransform2DLinear2 = (CogTransform2DLinear) t_FixtureTool2.RunParams.UnfixturedFromFixturedTransform; t_CogTransform2DLinear2.Rotation = 0; t_CogTransform2DLinear2.TranslationX = -t_CurrentX; t_CogTransform2DLinear2.TranslationY = -t_CurrentY; t_FixtureTool2.RunParams.UnfixturedFromFixturedTransform = t_CogTransform2DLinear2; t_FixtureTool2.Run(); if (t_FixtureTool2.RunStatus.Result != CogToolResultConstants.Accept) { result = t_FixtureTool2.RunStatus.Result; message = \u0026#34;FixtureTool2 Run ERROR\u0026#34;; return false; } //mToolBlock.Outputs[\u0026#34;OutputImage\u0026#34;].Value = t_FixtureTool2.OutputImage; t_Label.SetXYText(200, 300, \u0026#34;Space 转换成功！\u0026#34;); result = CogToolResultConstants.Accept; #endregion } else { result = CogToolResultConstants.Error; message = \u0026#34;Commandstr 运行模式 参数错误\u0026#34;; t_Label.SetXYText(200, 300, \u0026#34;RunMode 运行模式 参数错误\u0026#34;); m_GraphicCollection.Add(t_Label.Copy(CogCopyShapeConstants.All)); } mToolBlock.Outputs[\u0026#34;OutputGraphics\u0026#34;].Value = m_GraphicCollection; return false; } #region When the Current Run Record is Created /// \u0026lt;summary\u0026gt; /// Called when the current record may have changed and is being reconstructed /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;currentRecord\u0026#34;\u0026gt; /// The new currentRecord is available to be initialized or customized.\u0026lt;/param\u0026gt; public override void ModifyCurrentRunRecord(Cognex.VisionPro.ICogRecord currentRecord) { } #endregion #region When the Last Run Record is Created /// \u0026lt;summary\u0026gt; /// Called when the last run record may have changed and is being reconstructed /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;lastRecord\u0026#34;\u0026gt; /// The new last run record is available to be initialized or customized.\u0026lt;/param\u0026gt; public override void ModifyLastRunRecord(Cognex.VisionPro.ICogRecord lastRecord) { for(int i = 0;i \u0026lt; m_GraphicCollection.Count ;i++) { mToolBlock.AddGraphicToRunRecord(m_GraphicCollection[i], lastRecord, \u0026#34;CogFixtureTool1.OutputImage\u0026#34;, \u0026#34;script\u0026#34;); } } #endregion #region When the Script is Initialized /// \u0026lt;summary\u0026gt; /// Perform any initialization required by your script here /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;host\u0026#34;\u0026gt;The host tool\u0026lt;/param\u0026gt; public override void Initialize(Cognex.VisionPro.ToolGroup.CogToolGroup host) { // DO NOT REMOVE - Call the base class implementation first - DO NOT REMOVE base.Initialize(host); // Store a local copy of the script host this.mToolBlock = ((Cognex.VisionPro.ToolBlock.CogToolBlock)(host)); } #endregion } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 #region namespace imports using System; using System.Collections; using System.Drawing; using System.IO; using System.Windows.Forms; using Cognex.VisionPro; using Cognex.VisionPro.ToolBlock; using Cognex.VisionPro3D; using Cognex.VisionPro.CalibFix; #endregion public class CogToolBlockAdvancedScript : CogToolBlockAdvancedScriptBase { #region Private Member Variables private Cognex.VisionPro.ToolBlock.CogToolBlock mToolBlock; #endregion /// \u0026lt;summary\u0026gt; /// Called when the parent tool is run. /// Add code here to customize or replace the normal run behavior. /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;message\u0026#34;\u0026gt;Sets the Message in the tool\u0026#39;s RunStatus.\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;result\u0026#34;\u0026gt;Sets the Result in the tool\u0026#39;s RunStatus\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;True if the tool should run normally, /// False if GroupRun customizes run behavior\u0026lt;/returns\u0026gt; public override bool GroupRun(ref string message, ref CogToolResultConstants result) { // To let the execution stop in this script when a debugger is attached, uncomment the following lines. // #if DEBUG // if (System.Diagnostics.Debugger.IsAttached) System.Diagnostics.Debugger.Break(); // #endif // Run each tool using the RunTool function // foreach(ICogTool tool in mToolBlock.Tools) // mToolBlock.RunTool(tool, ref message, ref result); CogImage8Grey t_InputImage = (CogImage8Grey) mToolBlock.Inputs[\u0026#34;InputImage\u0026#34;].Value; double t_TrainX1 = (double)mToolBlock.Inputs[\u0026#34;TrainX1\u0026#34;].Value; double t_TrainY1 = (double) mToolBlock.Inputs[\u0026#34;TrainY1\u0026#34;].Value; double t_CurrentX1 = (double) mToolBlock.Inputs[\u0026#34;CurrentX1\u0026#34;].Value; double t_CurrentY1 = (double) mToolBlock.Inputs[\u0026#34;CurrentY1\u0026#34;].Value; if (t_InputImage == null) { result = CogToolResultConstants.Error; message = \u0026#34;FindMarkPoint 未输入图像!\u0026#34;; return false; } string t_RootSpaceName = t_InputImage.SelectedSpaceName; CogFixtureNPointToNPointTool t_FixtureNPointToNPointTool1 = (CogFixtureNPointToNPointTool) mToolBlock.Tools[\u0026#34;CogFixtureNPointToNPointTool1\u0026#34;]; t_FixtureNPointToNPointTool1.RunParams.SetUnfixturedPoint(0, t_TrainX1, t_TrainY1); t_FixtureNPointToNPointTool1.RunParams.SetRawFixturedPoint(0, t_CurrentX1, t_CurrentY1); t_FixtureNPointToNPointTool1.InputImage = t_InputImage; t_FixtureNPointToNPointTool1.Run(); if (t_FixtureNPointToNPointTool1.RunStatus.Result != CogToolResultConstants.Accept) { result = t_FixtureNPointToNPointTool1.RunStatus.Result; message = \u0026#34;CogFixtureNPointToNPointTool1 Run Error!\u0026#34;; return false; } string t_CurrentSpaceName = t_FixtureNPointToNPointTool1.Result.OutputImage.SelectedSpaceName; // ICogTransform2D t_Transform2D = t_FixtureNPointToNPointTool1.Result.OutputImage.GetTransform(t_CurrentSpaceName, t_RootSpaceName); ICogTransform2D t_Transform2D = t_FixtureNPointToNPointTool1.Result.GetUnfixturedFromFixturedTransform().InvertBase(); mToolBlock.Outputs[\u0026#34;OutputTransform2D\u0026#34;].Value = t_Transform2D; mToolBlock.Outputs[\u0026#34;OutputRMS\u0026#34;].Value = t_FixtureNPointToNPointTool1.Result.RMSError; return false; } #region When the Current Run Record is Created /// \u0026lt;summary\u0026gt; /// Called when the current record may have changed and is being reconstructed /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;currentRecord\u0026#34;\u0026gt; /// The new currentRecord is available to be initialized or customized.\u0026lt;/param\u0026gt; public override void ModifyCurrentRunRecord(Cognex.VisionPro.ICogRecord currentRecord) { } #endregion #region When the Last Run Record is Created /// \u0026lt;summary\u0026gt; /// Called when the last run record may have changed and is being reconstructed /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;lastRecord\u0026#34;\u0026gt; /// The new last run record is available to be initialized or customized.\u0026lt;/param\u0026gt; public override void ModifyLastRunRecord(Cognex.VisionPro.ICogRecord lastRecord) { } #endregion #region When the Script is Initialized /// \u0026lt;summary\u0026gt; /// Perform any initialization required by your script here /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;host\u0026#34;\u0026gt;The host tool\u0026lt;/param\u0026gt; public override void Initialize(Cognex.VisionPro.ToolGroup.CogToolGroup host) { // DO NOT REMOVE - Call the base class implementation first - DO NOT REMOVE base.Initialize(host); // Store a local copy of the script host this.mToolBlock = ((Cognex.VisionPro.ToolBlock.CogToolBlock)(host)); } #endregion } 大面贴胶 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 cell_1 #region namespace imports using System; using System.Collections; using System.Drawing; using System.IO; using System.Windows.Forms; using Cognex.VisionPro; using Cognex.VisionPro.ToolBlock; using Cognex.VisionPro3D; using Cognex.VisionPro.ImageProcessing; #endregion public class CogToolBlockAdvancedScript : CogToolBlockAdvancedScriptBase { #region Private Member Variables private Cognex.VisionPro.ToolBlock.CogToolBlock mToolBlock; #endregion /// \u0026lt;summary\u0026gt; /// Called when the parent tool is run. /// Add code here to customize or replace the normal run behavior. /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;message\u0026#34;\u0026gt;Sets the Message in the tool\u0026#39;s RunStatus.\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;result\u0026#34;\u0026gt;Sets the Result in the tool\u0026#39;s RunStatus\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;True if the tool should run normally, /// False if GroupRun customizes run behavior\u0026lt;/returns\u0026gt; public override bool GroupRun(ref string message, ref CogToolResultConstants result) { // To let the execution stop in this script when a debugger is attached, uncomment the following lines. // #if DEBUG //if (System.Diagnostics.Debugger.IsAttached) System.Diagnostics.Debugger.Break(); // #endif // Run each tool using the RunTool function #region 输入输出 double MIN_Up_side = (double) mToolBlock.Inputs[\u0026#34;MIN_Up_side\u0026#34;].Value; double MAX_Up_side = (double) mToolBlock.Inputs[\u0026#34;MAX_Up_side\u0026#34;].Value; double MIN_Low_side = (double) mToolBlock.Inputs[\u0026#34;MIN_Low_side\u0026#34;].Value; double MAX_Low_side = (double) mToolBlock.Inputs[\u0026#34;MAX_Low_side\u0026#34;].Value; double MIN_Left_side = (double) mToolBlock.Inputs[\u0026#34;MIN_Left_side\u0026#34;].Value; double MAX_Left_side = (double) mToolBlock.Inputs[\u0026#34;MAX_Left_side\u0026#34;].Value; double MIN_Right_side = (double) mToolBlock.Inputs[\u0026#34;MIN_Right_side\u0026#34;].Value; double MAX_Right_side = (double) mToolBlock.Inputs[\u0026#34;MAX_Right_side\u0026#34;].Value; int Long_Caliper_Count = (int) mToolBlock.Inputs[\u0026#34;Long_Caliper_Count\u0026#34;].Value; int Short_Caliper_Count = (int) mToolBlock.Inputs[\u0026#34;Short_Caliper_Count\u0026#34;].Value; // double MAX_Two_side = (double) mToolBlock.Inputs[\u0026#34;MAX_Two_side\u0026#34;].Value; // double MIN_Two_side = (double) mToolBlock.Inputs[\u0026#34;MIN_Two_side\u0026#34;].Value; #endregion CogIPOneImageTool Tool_CogIPOneImageTool = new CogIPOneImageTool(); CogToolBlock Tool_CogToolBlock1 = new CogToolBlock(); CogToolBlock Tool_CogToolBlock2 = new CogToolBlock(); CogToolBlock Tool_CogToolBlock3 = new CogToolBlock(); CogToolBlock Tool_CogToolBlock4 = new CogToolBlock(); try {\tforeach(ICogTool tool in mToolBlock.Tools) { switch (tool.Name) { case \u0026#34;产品基准\u0026#34;: Tool_CogToolBlock2 = tool as CogToolBlock; mToolBlock.RunTool(tool, ref message, ref result); if (Tool_CogToolBlock2.RunStatus.Result != CogToolResultConstants.Accept) { message += tool.Name + \u0026#34;工具运行出错,\u0026#34;; } break; case \u0026#34;胶条找边\u0026#34;: Tool_CogToolBlock3 = tool as CogToolBlock; Tool_CogToolBlock3.Inputs[\u0026#34;Long_Caliper_Count\u0026#34;].Value = Long_Caliper_Count; Tool_CogToolBlock3.Inputs[\u0026#34;Short_Caliper_Count\u0026#34;].Value = Short_Caliper_Count; Tool_CogToolBlock3.Inputs[\u0026#34;Rectangle_Left\u0026#34;].Value = Tool_CogToolBlock2.Outputs[\u0026#34;Rectangle_Left\u0026#34;].Value; Tool_CogToolBlock3.Inputs[\u0026#34;Rectangle_Right\u0026#34;].Value = Tool_CogToolBlock2.Outputs[\u0026#34;Rectangle_Right\u0026#34;].Value; Tool_CogToolBlock3.Inputs[\u0026#34;Rectangle_Up\u0026#34;].Value = Tool_CogToolBlock2.Outputs[\u0026#34;Rectangle_Up\u0026#34;].Value; Tool_CogToolBlock3.Inputs[\u0026#34;Rectangle_Down\u0026#34;].Value = Tool_CogToolBlock2.Outputs[\u0026#34;Rectangle_Down\u0026#34;].Value; Tool_CogToolBlock3.Inputs[\u0026#34;MIN_Up_side\u0026#34;].Value = MIN_Up_side; Tool_CogToolBlock3.Inputs[\u0026#34;MAX_Up_side\u0026#34;].Value = MAX_Up_side; Tool_CogToolBlock3.Inputs[\u0026#34;MAX_Low_side\u0026#34;].Value = MAX_Low_side; Tool_CogToolBlock3.Inputs[\u0026#34;MIN_Low_side\u0026#34;].Value = MIN_Low_side; Tool_CogToolBlock3.Inputs[\u0026#34;MIN_Left_side\u0026#34;].Value = MIN_Left_side; Tool_CogToolBlock3.Inputs[\u0026#34;MAX_Left_side\u0026#34;].Value = MAX_Left_side; Tool_CogToolBlock3.Inputs[\u0026#34;MAX_Right_side\u0026#34;].Value = MAX_Right_side; Tool_CogToolBlock3.Inputs[\u0026#34;MIN_Right_side\u0026#34;].Value = MIN_Right_side; mToolBlock.RunTool(tool, ref message, ref result); if (Tool_CogToolBlock3.RunStatus.Result != CogToolResultConstants.Accept) { message += tool.Name + \u0026#34;工具运行出错,\u0026#34;; } else { mToolBlock.Outputs[\u0026#34;Result\u0026#34;].Value = Tool_CogToolBlock3.Outputs[\u0026#34;Result\u0026#34;].Value; } break; default: mToolBlock.RunTool(tool, ref message, ref result); break; } } } catch (Exception) { mToolBlock.Outputs[\u0026#34;Result\u0026#34;].Value = false; } return false; } #region When the Current Run Record is Created /// \u0026lt;summary\u0026gt; /// Called when the current record may have changed and is being reconstructed /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;currentRecord\u0026#34;\u0026gt; /// The new currentRecord is available to be initialized or customized.\u0026lt;/param\u0026gt; public override void ModifyCurrentRunRecord(Cognex.VisionPro.ICogRecord currentRecord) { } #endregion #region When the Last Run Record is Created /// \u0026lt;summary\u0026gt; /// Called when the last run record may have changed and is being reconstructed /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;lastRecord\u0026#34;\u0026gt; /// The new last run record is available to be initialized or customized.\u0026lt;/param\u0026gt; public override void ModifyLastRunRecord(Cognex.VisionPro.ICogRecord lastRecord) { } #endregion #region When the Script is Initialized /// \u0026lt;summary\u0026gt; /// Perform any initialization required by your script here /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;host\u0026#34;\u0026gt;The host tool\u0026lt;/param\u0026gt; public override void Initialize(Cognex.VisionPro.ToolGroup.CogToolGroup host) { // DO NOT REMOVE - Call the base class implementation first - DO NOT REMOVE base.Initialize(host); // Store a local copy of the script host this.mToolBlock = ((Cognex.VisionPro.ToolBlock.CogToolBlock) (host)); } #endregion } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 // 产品基准 #region namespace imports using System; using System.Collections; using System.Drawing; using System.IO; using System.Windows.Forms; using Cognex.VisionPro; using Cognex.VisionPro.ToolBlock; using Cognex.VisionPro3D; using Cognex.VisionPro.ImageProcessing; using Cognex.VisionPro.Caliper; #endregion public class CogToolBlockAdvancedScript : CogToolBlockAdvancedScriptBase { #region Private Member Variables private Cognex.VisionPro.ToolBlock.CogToolBlock mToolBlock; #endregion /// \u0026lt;summary\u0026gt; /// Called when the parent tool is run. /// Add code here to customize or replace the normal run behavior. /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;message\u0026#34;\u0026gt;Sets the Message in the tool\u0026#39;s RunStatus.\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;result\u0026#34;\u0026gt;Sets the Result in the tool\u0026#39;s RunStatus\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;True if the tool should run normally, /// False if GroupRun customizes run behavior\u0026lt;/returns\u0026gt; public override bool GroupRun(ref string message, ref CogToolResultConstants result) { // To let the execution stop in this script when a debugger is attached, uncomment the following lines. // #if DEBUG // if (System.Diagnostics.Debugger.IsAttached) System.Diagnostics.Debugger.Break(); // #endif // Run each tool using the RunTool function #region 生成数组类型 double[] ledf = new double[10]; CogToolBlockTerminal newT = new CogToolBlockTerminal(\u0026#34;Left\u0026#34;, ledf); if (mToolBlock.Outputs.Contains(\u0026#34;Left\u0026#34;) == false) { mToolBlock.Outputs.Add(newT); } CogToolBlockTerminal newR = new CogToolBlockTerminal(\u0026#34;Right\u0026#34;, ledf); if (mToolBlock.Outputs.Contains(\u0026#34;Right\u0026#34;) == false) { mToolBlock.Outputs.Add(newR); } CogToolBlockTerminal newU = new CogToolBlockTerminal(\u0026#34;Up\u0026#34;, ledf); if (mToolBlock.Outputs.Contains(\u0026#34;Up\u0026#34;) == false) { mToolBlock.Outputs.Add(newU); } CogToolBlockTerminal newD = new CogToolBlockTerminal(\u0026#34;Down\u0026#34;, ledf); if (mToolBlock.Outputs.Contains(\u0026#34;Down\u0026#34;) == false) { mToolBlock.Outputs.Add(newD); } #endregion #region 变量声明 CogFindLineTool Tool_CogFindLineTool1 = new CogFindLineTool(); CogFindLineTool Tool_CogFindLineTool2 = new CogFindLineTool(); CogFindLineTool Tool_CogFindLineTool3 = new CogFindLineTool(); CogFindLineTool Tool_CogFindLineTool4 = new CogFindLineTool(); #endregion #region 工具运行 CogToolBlock toolBlock1 = mToolBlock.Tools[\u0026#34;CogToolBlock1\u0026#34;] as CogToolBlock; toolBlock1.Run(); foreach(ICogTool tool in mToolBlock.Tools) switch (tool.Name) { case \u0026#34;Up\u0026#34;: Tool_CogFindLineTool1 = tool as CogFindLineTool; mToolBlock.RunTool(tool, ref message, ref result); if (Tool_CogFindLineTool1.Results.NumPointsFound == 0) { message = tool.Name + \u0026#34;工具运行错误，未找到边！\u0026#34;; //return false; } double [] Up = new double[Tool_CogFindLineTool1.Results.Count]; for (int i = 0; i \u0026lt; Tool_CogFindLineTool1.Results.Count; i++) { if (Tool_CogFindLineTool1.Results[i].Found) { Up[i] = Tool_CogFindLineTool1.Results[i].X; } } mToolBlock.Outputs[\u0026#34;Up\u0026#34;].Value = Up; break; case \u0026#34;Down\u0026#34;: Tool_CogFindLineTool2 = tool as CogFindLineTool; mToolBlock.RunTool(tool, ref message, ref result); if (Tool_CogFindLineTool2.Results.NumPointsFound == 0) { message += \u0026#34;;\u0026#34; + tool.Name + \u0026#34;工具运行错误，未找到边！\u0026#34;; //return false; } double [] Down = new double[Tool_CogFindLineTool2.Results.Count]; for (int i = 0; i \u0026lt; Tool_CogFindLineTool2.Results.Count; i++) { if (Tool_CogFindLineTool2.Results[i].Found) { Down[i] = Tool_CogFindLineTool2.Results[i].X; } } mToolBlock.Outputs[\u0026#34;Down\u0026#34;].Value = Down; break; case \u0026#34;Left\u0026#34;: Tool_CogFindLineTool3 = tool as CogFindLineTool; mToolBlock.RunTool(tool, ref message, ref result); if (Tool_CogFindLineTool3.Results.NumPointsFound == 0) { message += \u0026#34;;\u0026#34; + tool.Name + \u0026#34;工具运行错误，未找到边！\u0026#34;; //return false; } double [] left = new double[Tool_CogFindLineTool3.Results.Count]; for (int i = 0; i \u0026lt; Tool_CogFindLineTool3.Results.Count; i++) { if (Tool_CogFindLineTool3.Results[i].Found) { left[i] = Tool_CogFindLineTool3.Results[i].Y; } } mToolBlock.Outputs[\u0026#34;Left\u0026#34;].Value = left; break; case \u0026#34;Right\u0026#34;: Tool_CogFindLineTool4 = tool as CogFindLineTool; mToolBlock.RunTool(tool, ref message, ref result); if (Tool_CogFindLineTool4.Results.NumPointsFound == 0) { message += \u0026#34;;\u0026#34; + tool.Name + \u0026#34;工具运行错误，未找到边！\u0026#34;; //return false; } double [] RIGHT = new double[Tool_CogFindLineTool4.Results.Count]; for (int i = 0; i \u0026lt; Tool_CogFindLineTool4.Results.Count; i++) { if (Tool_CogFindLineTool4.Results[i].Found) { RIGHT[i] = Tool_CogFindLineTool4.Results[i].Y; } } mToolBlock.Outputs[\u0026#34;Right\u0026#34;].Value = RIGHT; break; default: mToolBlock.RunTool(tool, ref message, ref result); break; } #endregion return false; } #region When the Current Run Record is Created /// \u0026lt;summary\u0026gt; /// Called when the current record may have changed and is being reconstructed /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;currentRecord\u0026#34;\u0026gt; /// The new currentRecord is available to be initialized or customized.\u0026lt;/param\u0026gt; public override void ModifyCurrentRunRecord(Cognex.VisionPro.ICogRecord currentRecord) { } #endregion #region When the Last Run Record is Created /// \u0026lt;summary\u0026gt; /// Called when the last run record may have changed and is being reconstructed /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;lastRecord\u0026#34;\u0026gt; /// The new last run record is available to be initialized or customized.\u0026lt;/param\u0026gt; public override void ModifyLastRunRecord(Cognex.VisionPro.ICogRecord lastRecord) { } #endregion #region When the Script is Initialized /// \u0026lt;summary\u0026gt; /// Perform any initialization required by your script here /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;host\u0026#34;\u0026gt;The host tool\u0026lt;/param\u0026gt; public override void Initialize(Cognex.VisionPro.ToolGroup.CogToolGroup host) { // DO NOT REMOVE - Call the base class implementation first - DO NOT REMOVE base.Initialize(host); // Store a local copy of the script host this.mToolBlock = ((Cognex.VisionPro.ToolBlock.CogToolBlock)(host)); } #endregion } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 // 胶条找边 #region namespace imports using System; using System.Collections; using System.Drawing; using System.IO; using System.Windows.Forms; using Cognex.VisionPro; using Cognex.VisionPro.ToolBlock; using Cognex.VisionPro3D; using Cognex.VisionPro.ColorExtractor; using Cognex.VisionPro.ImageProcessing; using Cognex.VisionPro.Blob; using Cognex.VisionPro.Caliper; using Cognex.VisionPro.Dimensioning; #endregion public class CogToolBlockAdvancedScript : CogToolBlockAdvancedScriptBase { #region Private Member Variables private Cognex.VisionPro.ToolBlock.CogToolBlock mToolBlock; private Cognex.VisionPro.CogGraphicCollection mCogGraphicCollection = new CogGraphicCollection(); //private Cognex.VisionPro.CogGraphicLabel mCogGraphicLabel; #endregion /// \u0026lt;summary\u0026gt; /// Called when the parent tool is run. /// Add code here to customize or replace the normal run behavior. /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;message\u0026#34;\u0026gt;Sets the Message in the tool\u0026#39;s RunStatus.\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;result\u0026#34;\u0026gt;Sets the Result in the tool\u0026#39;s RunStatus\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;True if the tool should run normally, /// False if GroupRun customizes run behavior\u0026lt;/returns\u0026gt; public override bool GroupRun(ref string message, ref CogToolResultConstants result) { // To let the execution stop in this script when a debugger is attached, uncomment the following lines. // #if DEBUG // if (System.Diagnostics.Debugger.IsAttached) System.Diagnostics.Debugger.Break(); // #endif // Run each tool using the RunTool function mCogGraphicCollection.Clear(); mToolBlock.Outputs[\u0026#34;find_side_Result\u0026#34;].Value = false; #region 输入 double MIN_Up_side = (double) mToolBlock.Inputs[\u0026#34;MIN_Up_side\u0026#34;].Value; double MAX_Up_side = (double) mToolBlock.Inputs[\u0026#34;MAX_Up_side\u0026#34;].Value; double MIN_Low_side = (double) mToolBlock.Inputs[\u0026#34;MIN_Low_side\u0026#34;].Value; double MAX_Low_side = (double) mToolBlock.Inputs[\u0026#34;MAX_Low_side\u0026#34;].Value; double MIN_Left_side = (double) mToolBlock.Inputs[\u0026#34;MIN_Left_side\u0026#34;].Value; double MAX_Left_side = (double) mToolBlock.Inputs[\u0026#34;MAX_Left_side\u0026#34;].Value; double MIN_Right_side = (double) mToolBlock.Inputs[\u0026#34;MIN_Right_side\u0026#34;].Value; double MAX_Right_side = (double) mToolBlock.Inputs[\u0026#34;MAX_Right_side\u0026#34;].Value; int Long_Caliper_Count = (int) mToolBlock.Inputs[\u0026#34;Long_Caliper_Count\u0026#34;].Value; int Short_Caliper_Count = (int) mToolBlock.Inputs[\u0026#34;Short_Caliper_Count\u0026#34;].Value; double Offset = (double) mToolBlock.Inputs[\u0026#34;Offset\u0026#34;].Value; double Angle_UP = 0; double [] left = new double[13]; left = (double []) mToolBlock.Inputs[\u0026#34;Left\u0026#34;].Value; double [] Right = new double[13]; Right = (double []) mToolBlock.Inputs[\u0026#34;Right\u0026#34;].Value; double [] Up = new double[13]; Up = (double []) mToolBlock.Inputs[\u0026#34;Up\u0026#34;].Value; double [] Down = new double[13]; Down = (double []) mToolBlock.Inputs[\u0026#34;Down\u0026#34;].Value; #endregion #region 变量声明 CogColorExtractorTool color = mToolBlock.Tools[\u0026#34;CogColorExtractorTool1\u0026#34;] as CogColorExtractorTool; CogImageConvertTool imageMp = mToolBlock.Tools[\u0026#34;CogImageConvertTool1\u0026#34;] as CogImageConvertTool; CogBlobTool mBlob = mToolBlock.Tools[\u0026#34;CogBlobTool1\u0026#34;] as CogBlobTool; CogBlobTool mBlob2 = mToolBlock.Tools[\u0026#34;CogBlobTool2\u0026#34;] as CogBlobTool; CogFindLineTool Tool_CogFindLineTool1 = mToolBlock.Tools[\u0026#34;CogFindLineTool1_Up\u0026#34;] as CogFindLineTool; CogFindLineTool Tool_CogFindLineTool2 = mToolBlock.Tools[\u0026#34;CogFindLineTool2_Down\u0026#34;] as CogFindLineTool; CogFindLineTool Tool_CogFindLineTool3 = mToolBlock.Tools[\u0026#34;CogFindLineTool3_Left\u0026#34;] as CogFindLineTool; CogFindLineTool Tool_CogFindLineTool4 = mToolBlock.Tools[\u0026#34;CogFindLineTool4_Right\u0026#34;] as CogFindLineTool; CogDistancePointLineTool Distance_Up = (CogDistancePointLineTool) mToolBlock.Tools[\u0026#34;Distance_Up\u0026#34;]; CogDistancePointLineTool Distance_Down = (CogDistancePointLineTool) mToolBlock.Tools[\u0026#34;Distance_Down\u0026#34;]; CogDistancePointLineTool Distance_Left = (CogDistancePointLineTool) mToolBlock.Tools[\u0026#34;Distance_Left\u0026#34;]; CogDistancePointLineTool Distance_Right = (CogDistancePointLineTool) mToolBlock.Tools[\u0026#34;Distance_Right\u0026#34;]; int Pattern_Angle = (int) mToolBlock.Inputs[\u0026#34;Pattern_Angle\u0026#34;].Value; CogLine Rectangle_Left = (CogLine) mToolBlock.Inputs[\u0026#34;Rectangle_Left\u0026#34;].Value; CogLine Rectangle_Right = (CogLine) mToolBlock.Inputs[\u0026#34;Rectangle_Right\u0026#34;].Value; CogLine Rectangle_Up = (CogLine) mToolBlock.Inputs[\u0026#34;Rectangle_Up\u0026#34;].Value; CogLine Rectangle_Down = (CogLine) mToolBlock.Inputs[\u0026#34;Rectangle_Down\u0026#34;].Value; string Data_Str1=\u0026#34;\u0026#34;,Data_Str2 = \u0026#34;\u0026#34;,Data_Str3 = \u0026#34;\u0026#34;,Data_Str4 = \u0026#34;\u0026#34;; CogToolBlock toolBlock1 = mToolBlock.Tools[\u0026#34;CogToolBlock1\u0026#34;] as CogToolBlock; double Line1_X,Line1_Y; double DistancePointLine1=0,DistancePointLine2 = 0,DistancePointLine3 = 0,DistancePointLine4 = 0; int Total_Result = 0; int Total_Result1 = 0; bool toosResult = true; #endregion #region 工具运行 color.Run(); imageMp.Run(); #region 判断离型纸有无 mBlob.Run(); if (mBlob.Results.GetBlobs().Count \u0026gt; 0) { mToolBlock.Outputs[\u0026#34;find_side_Result\u0026#34;].Value = true; message = mBlob.Name + \u0026#34;工具运行错误，有离心纸残留！\u0026#34;; CogGraphicLabel myLabel = new CogGraphicLabel(); myLabel.SelectedSpaceName = \u0026#34;#\u0026#34;; myLabel.Color = CogColorConstants.Red; myLabel.Font = new Font(\u0026#34;宋体\u0026#34;, 20); myLabel.SetXYText(3000, 500, message); mCogGraphicCollection.Add(myLabel); mToolBlock.Outputs[\u0026#34;Result\u0026#34;].Value = false; return false; } mBlob2.Run(); if (mBlob2.Results.GetBlobs().Count \u0026gt; 0) { for (int i = 0; i \u0026lt; mBlob2.Results.GetBlobs().Count; i++) { message = mBlob2.Name + \u0026#34;工具运行错误，异物！\u0026#34;; CogGraphicLabel myLabel2 = new CogGraphicLabel(); //myLabel2.SelectedSpaceName = \u0026#34;#\u0026#34;; myLabel2.Color = CogColorConstants.Red; myLabel2.Font = new Font(\u0026#34;宋体\u0026#34;, 30); myLabel2.SetXYText(mBlob2.Results.GetBlobs()[i].CenterOfMassX, mBlob2.Results.GetBlobs()[i].CenterOfMassY, message); mCogGraphicCollection.Add(myLabel2); mToolBlock.Outputs[\u0026#34;Result\u0026#34;].Value = false; } } #endregion #region 上下抓边 #region 先抓取上边 Tool_CogFindLineTool1.Run(); if (Tool_CogFindLineTool1.Results.NumPointsFound == 0 ) { mToolBlock.Outputs[\u0026#34;find_side_Result\u0026#34;].Value = true; message = Tool_CogFindLineTool1.Name + \u0026#34;工具运行错误，漏贴胶或贴胶倾斜！\u0026#34;; CogGraphicLabel myLabel = new CogGraphicLabel(); myLabel.SelectedSpaceName = \u0026#34;#\u0026#34;; myLabel.Color = CogColorConstants.Red; myLabel.Font = new Font(\u0026#34;宋体\u0026#34;, 20); myLabel.SetXYText(3000, 500, message); mCogGraphicCollection.Add(myLabel); mToolBlock.Outputs[\u0026#34;Result\u0026#34;].Value = false; //return false; } else { for (int i = 0; i \u0026lt; Tool_CogFindLineTool1.Results.NumPointsFound; i++) { if (Tool_CogFindLineTool1.Results[i].Used == true) { Distance_Up.X = Tool_CogFindLineTool1.Results[i].X; Distance_Up.Y = Tool_CogFindLineTool1.Results[i].Y; Distance_Up.Line = Rectangle_Up; Distance_Up.Run(); // if (Tool_CogFindLineTool1.Results[i].X \u0026gt; Up[i]) // { // DistancePointLine1 = Distance_Up.Distance; // } // else // { // DistancePointLine1 = Distance_Up.Distance; // } DistancePointLine1 = Distance_Up.Distance; Line1_X = Distance_Up.LineX; Line1_Y = Distance_Up.LineY; if ( Distance_Up.X \u0026gt; Line1_X) { DistancePointLine1 = -Distance_Up.Distance; } CogLineSegment mCogLineSegment1 = new CogLineSegment(); CogGraphicLabel mLabel1 = new CogGraphicLabel(); mLabel1.Rotation = CogMisc.DegToRad(-90); if (DistancePointLine1 \u0026gt; MIN_Up_side \u0026amp;\u0026amp; DistancePointLine1 \u0026lt; MAX_Up_side) { mCogLineSegment1.SetStartEnd(Tool_CogFindLineTool1.Results[i].X, Tool_CogFindLineTool1.Results[i].Y, Line1_X, Line1_Y); mCogLineSegment1.Color = CogColorConstants.Blue; mLabel1.SetXYText(mCogLineSegment1.MidpointX, mCogLineSegment1.MidpointY, DistancePointLine1.ToString(\u0026#34;F2\u0026#34;)); mLabel1.Color = CogColorConstants.Green; //mLabel1.Rotation = 180; } else { mCogLineSegment1.SetStartEnd(Tool_CogFindLineTool1.Results[i].X, Tool_CogFindLineTool1.Results[i].Y, Line1_X, Line1_Y); mCogLineSegment1.Color = CogColorConstants.Cyan; mLabel1.SetXYText(mCogLineSegment1.MidpointX, mCogLineSegment1.MidpointY, DistancePointLine1.ToString(\u0026#34;F2\u0026#34;)); mLabel1.Color = CogColorConstants.Red; toosResult = false; Total_Result++; } Data_Str1 += DistancePointLine1.ToString(\u0026#34;F2\u0026#34;) + \u0026#34;,\u0026#34;; mCogGraphicCollection.Add(mCogLineSegment1); mCogGraphicCollection.Add(mLabel1); } } } #endregion #region 上边抓边失败启用下边 // if (toosResult == false) { // toosResult = true; //Total_Result = 0; Tool_CogFindLineTool2.Run(); if (Tool_CogFindLineTool2.Results.NumPointsFound == 0) { mToolBlock.Outputs[\u0026#34;find_side_Result\u0026#34;].Value = true; message += \u0026#34;;\u0026#34; + Tool_CogFindLineTool2.Name + \u0026#34;工具运行错误，未找到边！\u0026#34;; Total_Result++; } else { for (int i = 0; i \u0026lt; Tool_CogFindLineTool2.Results.NumPointsFound; i++) { if (Tool_CogFindLineTool2.Results[i].Used == true) { Distance_Down.X = Tool_CogFindLineTool2.Results[i].X; Distance_Down.Y = Tool_CogFindLineTool2.Results[i].Y; Distance_Down.Line = Rectangle_Down; Distance_Down.Run(); // if (Tool_CogFindLineTool2.Results[i].X \u0026lt; Down[i]) // { // DistancePointLine2 = -Distance_Down.Distance; // } // else // { // DistancePointLine2 = Distance_Down.Distance; // } DistancePointLine2 = Distance_Down.Distance; Line1_X = Distance_Down.LineX; Line1_Y = Distance_Down.LineY; if ( Distance_Down.X \u0026lt; Line1_X) { DistancePointLine2 = -Distance_Down.Distance; } CogLineSegment mCogLineSegment2 = new CogLineSegment(); CogGraphicLabel mLabel2 = new CogGraphicLabel(); mLabel2.Rotation = CogMisc.DegToRad(-90); if (DistancePointLine2 \u0026gt; MIN_Low_side \u0026amp;\u0026amp; DistancePointLine2 \u0026lt; MAX_Low_side) { mCogLineSegment2.SetStartEnd(Tool_CogFindLineTool2.Results[i].X, Tool_CogFindLineTool2.Results[i].Y, Line1_X, Line1_Y); mCogLineSegment2.Color = CogColorConstants.Blue; // mCogLineSegment2.SelectedSpaceName = @\u0026#34;\\Checkerboard Calibration\\Fixture22\u0026#34;; mLabel2.SetXYText(mCogLineSegment2.MidpointX, mCogLineSegment2.MidpointY, DistancePointLine2.ToString(\u0026#34;F2\u0026#34;)); mLabel2.Color = CogColorConstants.Green; } else { mCogLineSegment2.SetStartEnd(Tool_CogFindLineTool2.Results[i].X, Tool_CogFindLineTool2.Results[i].Y, Line1_X, Line1_Y); mCogLineSegment2.Color = CogColorConstants.Cyan; mLabel2.SetXYText(mCogLineSegment2.MidpointX, mCogLineSegment2.MidpointY, DistancePointLine2.ToString(\u0026#34;F2\u0026#34;)); mLabel2.Color = CogColorConstants.Red; Total_Result++; } Data_Str2 += DistancePointLine2.ToString(\u0026#34;F2\u0026#34;) + \u0026#34;,\u0026#34;; mCogGraphicCollection.Add(mCogLineSegment2); mCogGraphicCollection.Add(mLabel2); } } } } #endregion #endregion #region 左右抓边 #region 先抓取左边 Tool_CogFindLineTool3.Run(); if (Tool_CogFindLineTool3.Results.NumPointsFound == 0) { mToolBlock.Outputs[\u0026#34;find_side_Result\u0026#34;].Value = true; message += \u0026#34;;\u0026#34; + Tool_CogFindLineTool3.Name + \u0026#34;工具运行错误，未找到边！\u0026#34;; Total_Result1++; //return false; } else { for (int i = 0; i \u0026lt; Tool_CogFindLineTool3.Results.NumPointsFound; i++) { if (Tool_CogFindLineTool3.Results[i].Used == true) { Distance_Left.X = Tool_CogFindLineTool3.Results[i].X; Distance_Left.Y = Tool_CogFindLineTool3.Results[i].Y; Distance_Left.Line = Rectangle_Left; Distance_Left.Run(); // if (Tool_CogFindLineTool3.Results[i].Y \u0026lt; left[i]) // { // DistancePointLine3 = Distance_Left.Distance; // } // else // { // DistancePointLine3 = -Distance_Left.Distance; // } DistancePointLine3 = Distance_Left.Distance + Offset; Line1_X = Distance_Left.LineX; Line1_Y = Distance_Left.LineY; if (Distance_Left.Y\u0026gt;Line1_Y) { DistancePointLine3 = -(Distance_Left.Distance); } CogLineSegment mCogLineSegment3 = new CogLineSegment(); CogGraphicLabel mLabel3 = new CogGraphicLabel(); mLabel3.Rotation = CogMisc.DegToRad(-90); if (DistancePointLine3 \u0026gt; MIN_Left_side \u0026amp;\u0026amp; DistancePointLine3 \u0026lt; MAX_Left_side) { mCogLineSegment3.SetStartEnd(Tool_CogFindLineTool3.Results[i].X, Tool_CogFindLineTool3.Results[i].Y, Line1_X, Line1_Y); mCogLineSegment3.Color = CogColorConstants.Blue; mLabel3.SetXYText(mCogLineSegment3.MidpointX, mCogLineSegment3.MidpointY, DistancePointLine3.ToString(\u0026#34;F2\u0026#34;)); mLabel3.Color = CogColorConstants.Green; } else { mCogLineSegment3.SetStartEnd(Tool_CogFindLineTool3.Results[i].X, Tool_CogFindLineTool3.Results[i].Y, Line1_X, Line1_Y); mCogLineSegment3.Color = CogColorConstants.Cyan; mLabel3.SetXYText(mCogLineSegment3.MidpointX, mCogLineSegment3.MidpointY, DistancePointLine3.ToString(\u0026#34;F2\u0026#34;)); mLabel3.Color = CogColorConstants.Red; Total_Result1++; toosResult = false; } Data_Str3 += DistancePointLine3.ToString(\u0026#34;F2\u0026#34;) + \u0026#34;,\u0026#34;; mCogGraphicCollection.Add(mCogLineSegment3); mCogGraphicCollection.Add(mLabel3); } } } #endregion #region 左边抓边错误启用右边 // if (toosResult == false) { // Total_Result1 = 0; // toosResult = true; Tool_CogFindLineTool4.Run(); if (Tool_CogFindLineTool4.Results.NumPointsFound == 0) { mToolBlock.Outputs[\u0026#34;find_side_Result\u0026#34;].Value = true; message += \u0026#34;;\u0026#34; + Tool_CogFindLineTool4.Name + \u0026#34;工具运行错误，未找到边！\u0026#34;; Total_Result1++; //return false; } else { for (int i = 0; i \u0026lt; Tool_CogFindLineTool4.Results.NumPointsFound; i++) { if (Tool_CogFindLineTool4.Results[i].Used == true) { Distance_Right.X = Tool_CogFindLineTool4.Results[i].X; Distance_Right.Y = Tool_CogFindLineTool4.Results[i].Y; Distance_Right.Line = Rectangle_Right; Distance_Right.Run(); // if (Tool_CogFindLineTool4.Results[i].Y \u0026gt; Right[i]) // { // DistancePointLine4 = Distance_Right.Distance; // } // else // { // DistancePointLine4 = -Distance_Right.Distance; // } DistancePointLine4 = Distance_Right.Distance; Line1_X = Distance_Right.LineX; Line1_Y = Distance_Right.LineY; if (Distance_Right.Y \u0026lt; Line1_Y) { mToolBlock.Outputs[\u0026#34;find_side_Result\u0026#34;].Value = true; DistancePointLine4 = -Distance_Right.Distance; } CogLineSegment mCogLineSegment4 = new CogLineSegment(); CogGraphicLabel mLabel4 = new CogGraphicLabel(); mLabel4.Rotation = CogMisc.DegToRad(-90); if (DistancePointLine4 \u0026gt;= MIN_Right_side \u0026amp;\u0026amp; DistancePointLine4 \u0026lt; MAX_Right_side)//DistancePointLine4 \u0026gt; MIN_Right_side \u0026amp;\u0026amp; { mCogLineSegment4.SetStartEnd(Tool_CogFindLineTool4.Results[i].X, Tool_CogFindLineTool4.Results[i].Y, Line1_X, Line1_Y); mCogLineSegment4.Color = CogColorConstants.Blue; mLabel4.SetXYText(mCogLineSegment4.MidpointX, mCogLineSegment4.MidpointY, DistancePointLine4.ToString(\u0026#34;F2\u0026#34;)); mLabel4.Color = CogColorConstants.Green; } else { mCogLineSegment4.SetStartEnd(Tool_CogFindLineTool4.Results[i].X, Tool_CogFindLineTool4.Results[i].Y, Line1_X, Line1_Y); mCogLineSegment4.Color = CogColorConstants.Cyan; mLabel4.SetXYText(mCogLineSegment4.MidpointX, mCogLineSegment4.MidpointY, DistancePointLine4.ToString(\u0026#34;F2\u0026#34;)); mLabel4.Color = CogColorConstants.Red; Total_Result1++; } Data_Str4 += DistancePointLine4.ToString(\u0026#34;F2\u0026#34;) + \u0026#34;,\u0026#34;; mCogGraphicCollection.Add(mCogLineSegment4); mCogGraphicCollection.Add(mLabel4); } } } } toolBlock1.Run(); bool t_result = (bool)toolBlock1.Outputs[\u0026#34;Result\u0026#34;].Value; #endregion #endregion #endregion string l; //判断基准边和胶边不能为空，否则NG if (Rectangle_Left != null \u0026amp;\u0026amp; Rectangle_Right != null \u0026amp;\u0026amp; Rectangle_Up != null \u0026amp;\u0026amp; Rectangle_Down != null \u0026amp;\u0026amp; Tool_CogFindLineTool1.Results.GetLine() != null \u0026amp;\u0026amp; Tool_CogFindLineTool2.Results.GetLine() != null \u0026amp;\u0026amp; Tool_CogFindLineTool3.Results.GetLine() != null \u0026amp;\u0026amp; Tool_CogFindLineTool4.Results.GetLine() != null) { } else { Total_Result++; } if (Total_Result \u0026gt; 0 || Total_Result1 \u0026gt; 0||!t_result) { mToolBlock.Outputs[\u0026#34;Result\u0026#34;].Value = false; l = \u0026#34;,NG\u0026#34;; } else { mToolBlock.Outputs[\u0026#34;Result\u0026#34;].Value = true; l = \u0026#34;,OK\u0026#34;; } CSV1(DateTime.Now.ToString(\u0026#34;HH:mm:ss\u0026#34;) + \u0026#34;,\u0026#34; + Data_Str1 + l, @\u0026#34;E:\\\\Data\\\\Cam1\\\\第一段\\\\Up_Data\u0026#34;); CSV2(DateTime.Now.ToString(\u0026#34;HH:mm:ss\u0026#34;) + \u0026#34;,\u0026#34; + Data_Str2 + l, @\u0026#34;E:\\\\Data\\\\Cam1\\\\第一段\\\\Down_Data\u0026#34;); CSV2(DateTime.Now.ToString(\u0026#34;HH:mm:ss\u0026#34;) + \u0026#34;,\u0026#34; + Data_Str3 + l, @\u0026#34;E:\\\\Data\\\\Cam1\\\\第一段\\\\Left_Data\u0026#34;); CSV4(DateTime.Now.ToString(\u0026#34;HH:mm:ss\u0026#34;) + \u0026#34;,\u0026#34; + Data_Str4 + l, @\u0026#34;E:\\\\Data\\\\Cam1\\\\第一段\\\\Right_Data\u0026#34;); return false; } #region 保存数据1 string Data_Name1; public void CSV1(string Data, string path) { int Long_Caliper_Count = (int) mToolBlock.Inputs[\u0026#34;Long_Caliper_Count\u0026#34;].Value; //int Short_Caliper_Count = (int) mToolBlock.Inputs[\u0026#34;Short_Caliper_Count\u0026#34;].Value; if (!Directory.Exists(path)) { Directory.CreateDirectory(path); } string filepath = path + \u0026#34;\\\\\u0026#34; + DateTime.Now.ToString(\u0026#34;yyyyMMdd\u0026#34;) + \u0026#34;.csv\u0026#34;; if (!File.Exists(filepath)) { File.Create(filepath).Dispose(); using (StreamWriter sw = new StreamWriter(filepath, true)) { for (int i = 0; i \u0026lt; Long_Caliper_Count; i++) { Data_Name1 += \u0026#34;Distance\u0026#34; + (i + 1) + \u0026#34;,\u0026#34;; } sw.WriteLine(\u0026#34;Time,\u0026#34; + Data_Name1 + \u0026#34;,Result\u0026#34;); sw.Close(); } } using (StreamWriter sw = new StreamWriter(filepath, true)) { sw.WriteLine(Data); sw.Close(); } } #endregion #region 保存数据2 string Data_Name2; public void CSV2(string Data, string path) { int Short_Caliper_Count = (int) mToolBlock.Inputs[\u0026#34;Short_Caliper_Count\u0026#34;].Value; if (!Directory.Exists(path)) { Directory.CreateDirectory(path); } string filepath = path + \u0026#34;\\\\\u0026#34; + DateTime.Now.ToString(\u0026#34;yyyyMMdd\u0026#34;) + \u0026#34;.csv\u0026#34;; if (!File.Exists(filepath)) { File.Create(filepath).Dispose(); using (StreamWriter sw = new StreamWriter(filepath, true)) { for (int i = 0; i \u0026lt; Short_Caliper_Count; i++) { Data_Name2 += \u0026#34;Distance\u0026#34; + (i + 1) + \u0026#34;,\u0026#34;; } sw.WriteLine(\u0026#34;Time,\u0026#34; + Data_Name2 + \u0026#34;,Result\u0026#34;); sw.Close(); } } using (StreamWriter sw = new StreamWriter(filepath, true)) { sw.WriteLine(Data); sw.Close(); } } #endregion\t#region 保存数据3 string Data_Name3; public void CSV3(string Data, string path) { int Long_Caliper_Count = (int) mToolBlock.Inputs[\u0026#34;Long_Caliper_Count\u0026#34;].Value; //int Short_Caliper_Count = (int) mToolBlock.Inputs[\u0026#34;Short_Caliper_Count\u0026#34;].Value; if (!Directory.Exists(path)) { Directory.CreateDirectory(path); } string filepath = path + \u0026#34;\\\\\u0026#34; + DateTime.Now.ToString(\u0026#34;yyyyMMdd\u0026#34;) + \u0026#34;.csv\u0026#34;; if (!File.Exists(filepath)) { File.Create(filepath).Dispose(); using (StreamWriter sw = new StreamWriter(filepath, true)) { for (int i = 0; i \u0026lt; Long_Caliper_Count; i++) { Data_Name3 += \u0026#34;Distance\u0026#34; + (i + 1) + \u0026#34;,\u0026#34;; } sw.WriteLine(\u0026#34;Time,\u0026#34; + Data_Name3 + \u0026#34;,Result\u0026#34;); sw.Close(); } } using (StreamWriter sw = new StreamWriter(filepath, true)) { sw.WriteLine(Data); sw.Close(); } } #endregion #region 保存数据4 string Data_Name4; public void CSV4(string Data, string path) { int Short_Caliper_Count = (int) mToolBlock.Inputs[\u0026#34;Short_Caliper_Count\u0026#34;].Value; if (!Directory.Exists(path)) { Directory.CreateDirectory(path); } string filepath = path + \u0026#34;\\\\\u0026#34; + DateTime.Now.ToString(\u0026#34;yyyyMMdd\u0026#34;) + \u0026#34;.csv\u0026#34;; if (!File.Exists(filepath)) { File.Create(filepath).Dispose(); using (StreamWriter sw = new StreamWriter(filepath, true)) { for (int i = 0; i \u0026lt; Short_Caliper_Count; i++) { Data_Name4 += \u0026#34;Distance\u0026#34; + (i + 1) + \u0026#34;,\u0026#34;; } sw.WriteLine(\u0026#34;Time,\u0026#34; + Data_Name4 + \u0026#34;,Result\u0026#34;); sw.Close(); } } using (StreamWriter sw = new StreamWriter(filepath, true)) { sw.WriteLine(Data); sw.Close(); } } #endregion\t#region When the Current Run Record is Created /// \u0026lt;summary\u0026gt; /// Called when the current record may have changed and is being reconstructed /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;currentRecord\u0026#34;\u0026gt; /// The new currentRecord is available to be initialized or customized.\u0026lt;/param\u0026gt; public override void ModifyCurrentRunRecord(Cognex.VisionPro.ICogRecord currentRecord) { } #endregion #region When the Last Run Record is Created /// \u0026lt;summary\u0026gt; /// Called when the last run record may have changed and is being reconstructed /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;lastRecord\u0026#34;\u0026gt; /// The new last run record is available to be initialized or customized.\u0026lt;/param\u0026gt; public override void ModifyLastRunRecord(Cognex.VisionPro.ICogRecord lastRecord) { foreach (ICogGraphic mGraphic in mCogGraphicCollection) { mToolBlock.AddGraphicToRunRecord(mGraphic, lastRecord, \u0026#34;CogColorExtractorTool1.InputImage\u0026#34;, \u0026#34;\u0026#34;); } } #endregion #region When the Script is Initialized /// \u0026lt;summary\u0026gt; /// Perform any initialization required by your script here /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;host\u0026#34;\u0026gt;The host tool\u0026lt;/param\u0026gt; public override void Initialize(Cognex.VisionPro.ToolGroup.CogToolGroup host) { // DO NOT REMOVE - Call the base class implementation first - DO NOT REMOVE base.Initialize(host); // Store a local copy of the script host this.mToolBlock = ((Cognex.VisionPro.ToolBlock.CogToolBlock) (host)); } #endregion } 提取框PLC1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 cogrectangle rg = id.Region as Cogrectangle // 提取框 if (id.Result.centerY -re.y \u0026lt;re.height/2) { } /* Pma.Run(); if (Pma.Results.Count!=0) { if (Pma.Results[0].GetPose().Rotation\u0026gt;178) { mToolBlock.Outputs[\u0026#34;Result\u0026#34;].Value = true; mToolBlock.Outputs[\u0026#34;Palartiy\u0026#34;].Value = \u0026#34;2\u0026#34;; } else { mToolBlock.Outputs[\u0026#34;Result\u0026#34;].Value = true; mToolBlock.Outputs[\u0026#34;Palartiy\u0026#34;].Value = \u0026#34;1\u0026#34;; } } */ 离型纸检测 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 #region namespace imports using System; using System.Collections; using System.Drawing; using System.IO; using System.Windows.Forms; using Cognex.VisionPro; using Cognex.VisionPro.ToolBlock; using Cognex.VisionPro3D; using Cognex.VisionPro.ColorExtractor; using Cognex.VisionPro.Blob; #endregion public class CogToolBlockAdvancedScript : CogToolBlockAdvancedScriptBase { #region Private Member Variables private Cognex.VisionPro.ToolBlock.CogToolBlock mToolBlock; private CogBlobTool CogBlobTool1; #endregion /// \u0026lt;summary\u0026gt; /// Called when the parent tool is run. /// Add code here to customize or replace the normal run behavior. /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;message\u0026#34;\u0026gt;Sets the Message in the tool\u0026#39;s RunStatus.\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;result\u0026#34;\u0026gt;Sets the Result in the tool\u0026#39;s RunStatus\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;True if the tool should run normally, /// False if GroupRun customizes run behavior\u0026lt;/returns\u0026gt; public override bool GroupRun(ref string message, ref CogToolResultConstants result) { // To let the execution stop in this script when a debugger is attached, uncomment the following lines. // #if DEBUG // if (System.Diagnostics.Debugger.IsAttached) System.Diagnostics.Debugger.Break(); // #endif // Run each tool using the RunTool function mToolBlock.Outputs[\u0026#34;Result\u0026#34;].Value = false; foreach(ICogTool tool in mToolBlock.Tools) mToolBlock.RunTool(tool, ref message, ref result); double Area = 0; CogBlobTool1 = (CogBlobTool) mToolBlock.Tools[\u0026#34;CogBlobTool1\u0026#34;]; if(CogBlobTool1.Results.GetBlobs().Count \u0026gt; 0) { for(int i = 0;i \u0026lt; CogBlobTool1.Results.GetBlobs().Count;i++) { Area += CogBlobTool1.Results.GetBlobs()[i].Area; } } if(Area \u0026lt; (double) mToolBlock.Inputs[\u0026#34;BlobAreaUpLimit\u0026#34;].Value) { mToolBlock.Outputs[\u0026#34;Result\u0026#34;].Value = true; } else { mToolBlock.Outputs[\u0026#34;Result\u0026#34;].Value = false; } return false; } #region When the Current Run Record is Created /// \u0026lt;summary\u0026gt; /// Called when the current record may have changed and is being reconstructed /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;currentRecord\u0026#34;\u0026gt; /// The new currentRecord is available to be initialized or customized.\u0026lt;/param\u0026gt; public override void ModifyCurrentRunRecord(Cognex.VisionPro.ICogRecord currentRecord) { } #endregion #region When the Last Run Record is Created /// \u0026lt;summary\u0026gt; /// Called when the last run record may have changed and is being reconstructed /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;lastRecord\u0026#34;\u0026gt; /// The new last run record is available to be initialized or customized.\u0026lt;/param\u0026gt; public override void ModifyLastRunRecord(Cognex.VisionPro.ICogRecord lastRecord) { } #endregion #region When the Script is Initialized /// \u0026lt;summary\u0026gt; /// Perform any initialization required by your script here /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;host\u0026#34;\u0026gt;The host tool\u0026lt;/param\u0026gt; public override void Initialize(Cognex.VisionPro.ToolGroup.CogToolGroup host) { // DO NOT REMOVE - Call the base class implementation first - DO NOT REMOVE base.Initialize(host); // Store a local copy of the script host this.mToolBlock = ((Cognex.VisionPro.ToolBlock.CogToolBlock)(host)); } #endregion } PLC4-2 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 // 限位片 #region namespace imports using System; using System.Collections; using System.Collections.Generic; using System.Drawing; using System.IO; using System.Windows.Forms; using Cognex.VisionPro; using Cognex.VisionPro.ToolBlock; using Cognex.VisionPro3D; using Cognex.VisionPro.ImageProcessing; using Cognex.VisionPro.CalibFix; using Cognex.VisionPro.PMAlign; #endregion public class CogToolBlockAdvancedScript : CogToolBlockAdvancedScriptBase { #region Private Member Variables private Cognex.VisionPro.ToolBlock.CogToolBlock mToolBlock; private Cognex.VisionPro.CogGraphicCollection mCogGraphicCollection = new CogGraphicCollection(); //private List\u0026lt;ICogGraphic\u0026gt; mCogGraphicCollection = new List\u0026lt;ICogGraphic\u0026gt;(); #endregion /// \u0026lt;summary\u0026gt; /// Called when the parent tool is run. /// Add code here to customize or replace the normal run behavior. /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;message\u0026#34;\u0026gt;Sets the Message in the tool\u0026#39;s RunStatus.\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;result\u0026#34;\u0026gt;Sets the Result in the tool\u0026#39;s RunStatus\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;True if the tool should run normally, /// False if GroupRun customizes run behavior\u0026lt;/returns\u0026gt; public override bool GroupRun(ref string message, ref CogToolResultConstants result) { // To let the execution stop in this script when a debugger is attached, uncomment the following lines. // #if DEBUG // if (System.Diagnostics.Debugger.IsAttached) System.Diagnostics.Debugger.Break(); // #endif mCogGraphicCollection.Clear(); mToolBlock.Outputs[\u0026#34;Result\u0026#34;].Value = true; string mes = \u0026#34;\u0026#34;; mToolBlock.Outputs[1].Value = 999; mToolBlock.Outputs[2].Value = 999; mToolBlock.Outputs[3].Value = 999; mToolBlock.Outputs[4].Value = 999; mToolBlock.Outputs[5].Value = 999; double max1 = Convert.ToDouble(mToolBlock.Inputs[\u0026#34;Up_Max\u0026#34;].Value); double min1 = Convert.ToDouble(mToolBlock.Inputs[\u0026#34;Up_Min\u0026#34;].Value); double max2 = Convert.ToDouble(mToolBlock.Inputs[\u0026#34;Range_Max\u0026#34;].Value); double min2 = Convert.ToDouble(mToolBlock.Inputs[\u0026#34;Range_Min\u0026#34;].Value); double max3 = Convert.ToDouble(mToolBlock.Inputs[\u0026#34;Left_Max\u0026#34;].Value); double min3 = Convert.ToDouble(mToolBlock.Inputs[\u0026#34;Left_Min\u0026#34;].Value); // Run each tool using the RunTool function foreach(ICogTool tool in mToolBlock.Tools) { try {\tmToolBlock.RunTool(tool, ref message, ref result); } catch (Exception) { mToolBlock.Outputs[\u0026#34;Result\u0026#34;].Value = false; mToolBlock.Outputs[\u0026#34;Message\u0026#34;].Value = \u0026#34;测试方案运行异常\u0026#34;; return false; } } CogToolBlock tb1 = mToolBlock.Tools[\u0026#34;左右间距\u0026#34;] as CogToolBlock; CogToolBlock tb2 = mToolBlock.Tools[\u0026#34;上下间距\u0026#34;] as CogToolBlock; CogToolBlock tb3 = mToolBlock.Tools[\u0026#34;左间距\u0026#34;] as CogToolBlock; CogToolBlock tb4 = mToolBlock.Tools[\u0026#34;掉落\u0026#34;] as CogToolBlock; mToolBlock.Outputs[1].Value = tb2.Outputs[0].Value; mToolBlock.Outputs[2].Value = tb2.Outputs[1].Value; mToolBlock.Outputs[3].Value = tb1.Outputs[0].Value; mToolBlock.Outputs[4].Value = tb1.Outputs[1].Value; mToolBlock.Outputs[5].Value = tb3.Outputs[0].Value; double min = Convert.ToDouble(tb2.Outputs[\u0026#34;Min\u0026#34;].Value); double max = Convert.ToDouble(tb2.Outputs[\u0026#34;Max\u0026#34;].Value); if (!(bool) tb4.Outputs[\u0026#34;Result\u0026#34;].Value) { mes += \u0026#34; 限位片掉落 \u0026#34;; mToolBlock.Outputs[\u0026#34;Result\u0026#34;].Value = false; } if (min \u0026lt; min1 || max \u0026gt; max1) { mes += \u0026#34; 上下间距异常 \u0026#34;; mToolBlock.Outputs[\u0026#34;Result\u0026#34;].Value = false; } min = Convert.ToDouble(tb1.Outputs[\u0026#34;Min\u0026#34;].Value); max = Convert.ToDouble(tb1.Outputs[\u0026#34;Max\u0026#34;].Value); if (min \u0026lt; min2 || max \u0026gt; max2) { mes += \u0026#34; 左右间距异常 \u0026#34;; mToolBlock.Outputs[\u0026#34;Result\u0026#34;].Value = false; } min = Convert.ToDouble(tb3.Outputs[\u0026#34;Min\u0026#34;].Value); max = Convert.ToDouble(tb3.Outputs[\u0026#34;Max\u0026#34;].Value); if (min \u0026lt; min3 || max \u0026gt; max3) { mes += \u0026#34; 右间距异常 \u0026#34;; mToolBlock.Outputs[\u0026#34;Result\u0026#34;].Value = false; } show(mes); mToolBlock.Outputs[\u0026#34;Message\u0026#34;].Value = mes; return false; } void show(string message) { CogGraphicLabel myLabel = new CogGraphicLabel(); myLabel.SelectedSpaceName = \u0026#34;#\u0026#34;; myLabel.Color = CogColorConstants.Red; myLabel.Font = new Font(\u0026#34;宋体\u0026#34;, 16); myLabel.SetXYText(2222, 666, message); myLabel.Alignment = CogGraphicLabelAlignmentConstants.BottomLeft; mCogGraphicCollection.Add(myLabel); } #region When the Current Run Record is Created /// \u0026lt;summary\u0026gt; /// Called when the current record may have changed and is being reconstructed /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;currentRecord\u0026#34;\u0026gt; /// The new currentRecord is available to be initialized or customized.\u0026lt;/param\u0026gt; public override void ModifyCurrentRunRecord(Cognex.VisionPro.ICogRecord currentRecord) { } #endregion #region When the Last Run Record is Created /// \u0026lt;summary\u0026gt; /// Called when the last run record may have changed and is being reconstructed /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;lastRecord\u0026#34;\u0026gt; /// The new last run record is available to be initialized or customized.\u0026lt;/param\u0026gt; public override void ModifyLastRunRecord(Cognex.VisionPro.ICogRecord lastRecord) { foreach (ICogGraphic mGraphic in mCogGraphicCollection) { // mToolBlock.AddGraphicToRunRecord(mGraphic, lastRecord, \u0026#34;CogImageConvertTool1.InputImage\u0026#34;, \u0026#34;\u0026#34;); mToolBlock.AddGraphicToRunRecord(mGraphic, lastRecord, lastRecord.SubRecords[0].RecordKey, \u0026#34;\u0026#34;); } } #endregion #region When the Script is Initialized /// \u0026lt;summary\u0026gt; /// Perform any initialization required by your script here /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;host\u0026#34;\u0026gt;The host tool\u0026lt;/param\u0026gt; public override void Initialize(Cognex.VisionPro.ToolGroup.CogToolGroup host) { // DO NOT REMOVE - Call the base class implementation first - DO NOT REMOVE base.Initialize(host); // Store a local copy of the script host this.mToolBlock = ((Cognex.VisionPro.ToolBlock.CogToolBlock) (host)); } #endregion } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 //sx #region namespace imports using System; using System.Collections; using System.Collections.Generic; using System.Drawing; using System.IO; using System.Windows.Forms; using Cognex.VisionPro; using Cognex.VisionPro.ToolBlock; using Cognex.VisionPro3D; using Cognex.VisionPro.Caliper; #endregion public class MyPoint { double X = 0; double Y = 0; public MyPoint(double x, double y) { X = x; Y = y; } } public class CogToolBlockAdvancedScript : CogToolBlockAdvancedScriptBase { #region Private Member Variables private Cognex.VisionPro.ToolBlock.CogToolBlock mToolBlock; List\u0026lt;ICogGraphic\u0026gt; list = new List\u0026lt;ICogGraphic\u0026gt;(); #endregion /// \u0026lt;summary\u0026gt; /// Called when the parent tool is run. /// Add code here to customize or replace the normal run behavior. /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;message\u0026#34;\u0026gt;Sets the Message in the tool\u0026#39;s RunStatus.\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;result\u0026#34;\u0026gt;Sets the Result in the tool\u0026#39;s RunStatus\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;True if the tool should run normally, /// False if GroupRun customizes run behavior\u0026lt;/returns\u0026gt; public override bool GroupRun(ref string message, ref CogToolResultConstants result) { // To let the execution stop in this script when a debugger is attached, uncomment the following lines. // #if DEBUG // if (System.Diagnostics.Debugger.IsAttached) System.Diagnostics.Debugger.Break(); // #endif list.Clear(); ICogImage image = mToolBlock.Inputs[0].Value as ICogImage; CogLine Line = null; double max = -99; double min = 99; double max1 = Convert.ToDouble(mToolBlock.Inputs[\u0026#34;Range_Max\u0026#34;].Value); double min1 = Convert.ToDouble(mToolBlock.Inputs[\u0026#34;Range_Min\u0026#34;].Value); // Run each tool using the RunTool function foreach(ICogTool tool in mToolBlock.Tools) { try {\tmToolBlock.RunTool(tool, ref message, ref result); if (tool.Name.Contains(\u0026#34;基准\u0026#34;)) { CogFindLineTool fl1 = tool as CogFindLineTool; if (tool.RunStatus.Result != CogToolResultConstants.Accept || fl1.Results.NumPointsUsed \u0026lt; fl1.RunParams.NumCalipers * 0.6) { mToolBlock.Outputs[\u0026#34;Min\u0026#34;].Value = -999; mToolBlock.Outputs[\u0026#34;Max\u0026#34;].Value = 999; return false; } else { Line = fl1.Results.GetLine(); } } if (tool.Name.Contains(\u0026#34;测量\u0026#34;)) { CogFindLineTool fl2 = tool as CogFindLineTool; if (tool.RunStatus.Result != CogToolResultConstants.Accept || fl2.Results.NumPointsUsed \u0026lt; fl2.RunParams.NumCalipers * 0.6 || Line == null) { mToolBlock.Outputs[\u0026#34;Min\u0026#34;].Value = -999; mToolBlock.Outputs[\u0026#34;Max\u0026#34;].Value = 999; return false; } else { for (int i = 0; i \u0026lt; fl2.Results.Count; i++) { if(fl2.Results[i].Used) { double x,y; double dis = CogMath.DistancePointLine(fl2.Results[i].X, fl2.Results[i].Y, Line, image, out x, out y); if (dis \u0026lt; min) { min = dis; } if (dis \u0026gt; max) { max = dis; } if (dis \u0026lt; min1 || dis \u0026gt; max1) { AddLabel(x, y, dis.ToString(\u0026#34;0.00\u0026#34;), false, fl2.InputImage.SelectedSpaceName); } else { AddLabel(x, y, dis.ToString(\u0026#34;0.00\u0026#34;), true, fl2.InputImage.SelectedSpaceName); } } } } } } catch (Exception) { mToolBlock.Outputs[\u0026#34;Min\u0026#34;].Value = -999; mToolBlock.Outputs[\u0026#34;Max\u0026#34;].Value = 999; return false; } } mToolBlock.Outputs[\u0026#34;Max\u0026#34;].Value = max; mToolBlock.Outputs[\u0026#34;Min\u0026#34;].Value = min; return false; } public void AddLabel(double x, double y, string text, bool Re, string sapcename) { CogGraphicLabel label = new CogGraphicLabel(); label.SetXYText(x, y, text); label.Color = Re ? CogColorConstants.Green : CogColorConstants.Red; label.Rotation = CogMisc.DegToRad(0); label.Alignment = CogGraphicLabelAlignmentConstants.BottomLeft; label.SelectedSpaceName = sapcename; label.Font = new Font(\u0026#34;微软雅黑\u0026#34;, 10); list.Add(label); } #region When the Current Run Record is Created /// \u0026lt;summary\u0026gt; /// Called when the current record may have changed and is being reconstructed /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;currentRecord\u0026#34;\u0026gt; /// The new currentRecord is available to be initialized or customized.\u0026lt;/param\u0026gt; public override void ModifyCurrentRunRecord(Cognex.VisionPro.ICogRecord currentRecord) { } #endregion #region When the Last Run Record is Created /// \u0026lt;summary\u0026gt; /// Called when the last run record may have changed and is being reconstructed /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;lastRecord\u0026#34;\u0026gt; /// The new last run record is available to be initialized or customized.\u0026lt;/param\u0026gt; public override void ModifyLastRunRecord(Cognex.VisionPro.ICogRecord lastRecord) { foreach ( var item in list) { mToolBlock.AddGraphicToRunRecord(item, lastRecord, lastRecord.SubRecords[0].RecordKey, \u0026#34;\u0026#34;); } } #endregion #region When the Script is Initialized /// \u0026lt;summary\u0026gt; /// Perform any initialization required by your script here /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;host\u0026#34;\u0026gt;The host tool\u0026lt;/param\u0026gt; public override void Initialize(Cognex.VisionPro.ToolGroup.CogToolGroup host) { // DO NOT REMOVE - Call the base class implementation first - DO NOT REMOVE base.Initialize(host); // Store a local copy of the script host this.mToolBlock = ((Cognex.VisionPro.ToolBlock.CogToolBlock) (host)); } #endregion } old入箱 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 #region namespace imports using System; using System.Collections; using System.Drawing; using System.IO; using System.Windows.Forms; using Cognex.VisionPro; using Cognex.VisionPro.ToolBlock; using Cognex.VisionPro3D; using Cognex.VisionPro.CalibFix; #endregion public class CogToolBlockAdvancedScript : CogToolBlockAdvancedScriptBase { #region Private Member Variables private Cognex.VisionPro.ToolBlock.CogToolBlock mToolBlock; private CogGraphicCollection m_GraphicCollection ; private double m_ux = 0; private double m_uy = 0; private double m_ur = 0; #endregion /// \u0026lt;summary\u0026gt; /// Called when the parent tool is run. /// Add code here to customize or replace the normal run behavior. /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;message\u0026#34;\u0026gt;Sets the Message in the tool\u0026#39;s RunStatus.\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;result\u0026#34;\u0026gt;Sets the Result in the tool\u0026#39;s RunStatus\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;True if the tool should run normally, /// False if GroupRun customizes run behavior\u0026lt;/returns\u0026gt; public override bool GroupRun(ref string message, ref CogToolResultConstants result) { // To let the execution stop in this script when a debugger is attached, uncomment the following lines. // #if DEBUG // if (System.Diagnostics.Debugger.IsAttached) System.Diagnostics.Debugger.Break(); // #endif // Run each tool using the RunTool function //foreach(ICogTool tool in mToolBlock.Tools) //mToolBlock.RunTool(tool, ref message, ref result); //显示状态集 if(m_GraphicCollection == null) { m_GraphicCollection = new CogGraphicCollection(); } else { m_GraphicCollection.Clear(); } result = CogToolResultConstants.Error; //状态显示标签 CogGraphicLabel t_Label = new CogGraphicLabel(); //左对齐 t_Label.Alignment = CogGraphicLabelAlignmentConstants.BaselineLeft; //字体 t_Label.Font = new Font(\u0026#34;ss\u0026#34;, 18); //显示颜色 t_Label.Color = CogColorConstants.Green; //显示空间 t_Label.SelectedSpaceName = \u0026#34;#\u0026#34;; Cognex.VisionPro.CogImage8Grey t_InputImage = (Cognex.VisionPro.CogImage8Grey) mToolBlock.Inputs[\u0026#34;InputImage\u0026#34;].Value; //以图像中心为计算目标，图像中心畸变最小 double zx = t_InputImage.Width / 2; double zy = t_InputImage.Height / 2; double ux = 0; double uy = 0; //RunMode 运行模式 Calib:Run string t_RunMode = (string) mToolBlock.Inputs[\u0026#34;RunMode\u0026#34;].Value; //InverseRz RZ旋转方向取反 //移动机构为标准机器人时一般情况为False,不需要取反 //移动机构为行架时，需要根据实际情况，可能需要进行取反 bool t_InverseRz=(bool)mToolBlock.Inputs[\u0026#34;InverseRz\u0026#34;].Value; int t_InverseRzInt = t_InverseRz ? -1 : 1; //CheckerboardMove 标定时标定板移动，默认情况下False,标定板固定，相机移动 //True,标定板移动，相机固定 bool t_CheckerboardMove=(bool)mToolBlock.Inputs[\u0026#34;CheckerboardMove\u0026#34;].Value; int t_CheckerboardMoveInt = t_CheckerboardMove ? -1 : 1; CogCalibCheckerboardTool t_CheckerboardTool1 = (CogCalibCheckerboardTool) mToolBlock.Tools[\u0026#34;CogCalibCheckerboardTool1\u0026#34;]; CogCalibCheckerboardTool t_CheckerboardTool2 = (CogCalibCheckerboardTool) mToolBlock.Tools[\u0026#34;CogCalibCheckerboardTool2\u0026#34;]; CogCalibNPointToNPointTool t_NPointToNPointTool1 = (CogCalibNPointToNPointTool) mToolBlock.Tools[\u0026#34;CogCalibNPointToNPointTool1\u0026#34;]; CogFixtureTool t_FixtureTool1 = (CogFixtureTool) mToolBlock.Tools[\u0026#34;CogFixtureTool1\u0026#34;]; CogFixtureTool t_FixtureTool2 = (CogFixtureTool) mToolBlock.Tools[\u0026#34;CogFixtureTool2\u0026#34;]; double t_CurrentX = (double) mToolBlock.Inputs[\u0026#34;CurrentX\u0026#34;].Value * t_CheckerboardMoveInt; double t_CurrentY = (double) mToolBlock.Inputs[\u0026#34;CurrentY\u0026#34;].Value * t_CheckerboardMoveInt; double t_CurrentRZ = (double) mToolBlock.Inputs[\u0026#34;CurrentRZ\u0026#34;].Value; if (t_RunMode == \u0026#34;Calib\u0026#34;) { // 1; 当前标定序号 int t_CalibIndexint = (int) mToolBlock.Inputs[\u0026#34;CalibIndex\u0026#34;].Value; try { if(t_CalibIndexint == 1) { #region 9点第一点 //初始化标定 while (t_NPointToNPointTool1.Calibration.NumPoints != 0) { t_NPointToNPointTool1.Calibration.DeletePointPair(0); } t_CheckerboardTool1.InputImage = t_InputImage; t_CheckerboardTool1.Calibration.CalibrationImage = t_CheckerboardTool1.InputImage; t_CheckerboardTool1.Calibration.Calibrate(); t_CheckerboardTool1.Run(); if (t_CheckerboardTool1.RunStatus.Result != CogToolResultConstants.Accept) { result = t_CheckerboardTool1.RunStatus.Result; message = \u0026#34;CheckerboardTool1 Run ERROR\u0026#34;; return false; } t_Label.SetXYText(200, 300, \u0026#34;NP\u0026#34; + t_CalibIndexint.ToString() + \u0026#34;平移特征点抓取成功！\u0026#34;); m_GraphicCollection.Add(t_Label.Copy(CogCopyShapeConstants.All)); ICogTransform2D t_Transform2D1 = t_CheckerboardTool1.OutputImage.GetTransform(@\u0026#34;@\\Checkerboard Calibration1\u0026#34;, \u0026#34;@\u0026#34;) as ICogTransform2D; t_Transform2D1.MapPoint(zx, zy, out ux, out uy); t_NPointToNPointTool1.Calibration.AddPointPair(ux, uy, t_CurrentX, t_CurrentY); mToolBlock.Inputs[\u0026#34;CalibX\u0026#34;].Value = t_CurrentX * t_CheckerboardMoveInt; mToolBlock.Inputs[\u0026#34;CalibY\u0026#34;].Value = t_CurrentY * t_CheckerboardMoveInt; mToolBlock.Inputs[\u0026#34;CalibRZ\u0026#34;].Value = t_CurrentRZ; result = CogToolResultConstants.Accept; return false; #endregion } if((t_CalibIndexint \u0026gt; 1 \u0026amp;\u0026amp; t_CalibIndexint \u0026lt; 10)) { t_CheckerboardTool2.InputImage = t_InputImage; t_CheckerboardTool2.Calibration.CalibrationImage = t_CheckerboardTool2.InputImage; t_CheckerboardTool2.Calibration.Calibrate(); t_CheckerboardTool2.Run(); if (t_CheckerboardTool2.RunStatus.Result != CogToolResultConstants.Accept) { result = t_CheckerboardTool2.RunStatus.Result; message = \u0026#34;CheckerboardTool2 Run ERROR\u0026#34;; return false; } t_Label.SetXYText(200, 300, \u0026#34;NP\u0026#34; + t_CalibIndexint.ToString() + \u0026#34;平移特征点抓取成功！\u0026#34;); m_GraphicCollection.Add(t_Label.Copy(CogCopyShapeConstants.All)); ICogTransform2D t_Transform2D1 = t_CheckerboardTool2.OutputImage.GetTransform(@\u0026#34;@\\Checkerboard Calibration2\u0026#34;, \u0026#34;@\u0026#34;) as ICogTransform2D; t_Transform2D1.MapPoint(zx, zy, out ux, out uy); t_NPointToNPointTool1.Calibration.AddPointPair(ux, uy, t_CurrentX, t_CurrentY); if(t_CalibIndexint == 9) { //第9点对NP工具进行标定 t_NPointToNPointTool1.InputImage = t_CheckerboardTool1.OutputImage; t_NPointToNPointTool1.CalibrationImage = t_NPointToNPointTool1.InputImage; t_NPointToNPointTool1.Calibration.Calibrate(); t_NPointToNPointTool1.Run(); if (t_NPointToNPointTool1.RunStatus.Result != CogToolResultConstants.Accept) { result = t_NPointToNPointTool1.RunStatus.Result; message = \u0026#34;NPointToNPointTool1 Run ERROR\u0026#34;; return false; } t_Label.SetXYText(400, 300, \u0026#34;NP 畸变误差\u0026#34; + t_NPointToNPointTool1.Calibration.ComputedRMSError.ToString(\u0026#34;f3\u0026#34;)); m_GraphicCollection.Add(t_Label.Copy(CogCopyShapeConstants.All)); } result = CogToolResultConstants.Accept; } if( t_CalibIndexint \u0026gt; 9 \u0026amp;\u0026amp; t_CalibIndexint \u0026lt; 12) { t_CheckerboardTool2.InputImage = t_InputImage; t_CheckerboardTool2.Calibration.CalibrationImage = t_CheckerboardTool2.InputImage; t_CheckerboardTool2.Calibration.Calibrate(); t_CheckerboardTool2.Run(); if (t_CheckerboardTool2.RunStatus.Result != CogToolResultConstants.Accept) { result = t_CheckerboardTool2.RunStatus.Result; message = \u0026#34;CheckerboardTool2 Run ERROR\u0026#34;; return false; } t_Label.SetXYText(200, 300, \u0026#34;NP\u0026#34; + t_CalibIndexint.ToString() + \u0026#34;旋转特征点抓取成功！\u0026#34;); m_GraphicCollection.Add(t_Label.Copy(CogCopyShapeConstants.All)); double t_ux,t_uy; ICogTransform2D t_Transform2D1 = t_CheckerboardTool2.OutputImage.GetTransform(@\u0026#34;@\\Checkerboard Calibration2\u0026#34;, \u0026#34;@\u0026#34;) as ICogTransform2D; t_Transform2D1.MapPoint(zx, zy, out t_ux, out t_uy); ICogTransform2D t_Transform2D2 = (ICogTransform2D) t_NPointToNPointTool1.OutputImage.GetTransform(@\u0026#34;@\\Checkerboard Calibration1\\N-Point Calibration1\u0026#34;, @\u0026#34;@\\Checkerboard Calibration1\u0026#34;); t_Transform2D2.MapPoint(t_ux, t_uy, out ux, out uy); if(t_CalibIndexint == 10) { m_ux = ux; m_uy = uy; m_ur = t_CurrentRZ; result = CogToolResultConstants.Accept; } else if(t_CalibIndexint == 11) { double t_x1,t_y1,t_r1,t_x2,t_y2,t_r2; t_x1 = m_ux; t_y1 = m_uy; t_r1 = m_ur; t_x2 = ux; t_y2 = uy; t_r2 = t_CurrentRZ; double t_r = (t_r2 - t_r1) * t_InverseRzInt; double angle = Math.PI * t_r / 180; double CenterX = ((t_x1 + t_x2) / 2) + ((t_y1 - t_y2) / 2) * (Math.Sin(angle) / (1 - Math.Cos(angle))); double CenterY = ((t_y1 + t_y2) / 2) - ((t_x1 - t_x2) / 2) * (Math.Sin(angle) / (1 - Math.Cos(angle))); CogTransform2DLinear t_CogTransform2DLinear = (CogTransform2DLinear) t_FixtureTool1.RunParams.UnfixturedFromFixturedTransform; t_CogTransform2DLinear.TranslationX = CenterX; t_CogTransform2DLinear.TranslationY = CenterY; t_CogTransform2DLinear.Rotation = 0; t_FixtureTool1.RunParams.UnfixturedFromFixturedTransform = t_CogTransform2DLinear; t_FixtureTool1.InputImage = t_NPointToNPointTool1.OutputImage; t_FixtureTool1.Run(); if (t_FixtureTool1.RunStatus.Result != CogToolResultConstants.Accept) { result = t_FixtureTool1.RunStatus.Result; message = \u0026#34;FixtureTool1 Run ERROR\u0026#34;; return false; } t_Label.SetXYText(400, 300, \u0026#34;NP\u0026#34; + t_CalibIndexint.ToString() + \u0026#34;旋转中心标定成功！\u0026#34;); m_GraphicCollection.Add(t_Label.Copy(CogCopyShapeConstants.All)); result = CogToolResultConstants.Accept; } } } catch (Exception e) { result = CogToolResultConstants.Error; message = e.Message; t_Label.SetXYText(600, 300, \u0026#34;标定板特征点抓取失败，请重新矫正,标定点：\u0026#34; + t_CalibIndexint.ToString() + \u0026#34; \u0026#34; + e.Message); m_GraphicCollection.Add(t_Label.Copy(CogCopyShapeConstants.All)); } } else if(t_RunMode == \u0026#34;Run\u0026#34;) { #region 运行 t_CheckerboardTool1.InputImage = t_InputImage; t_CheckerboardTool1.Run(); if (t_CheckerboardTool1.RunStatus.Result != CogToolResultConstants.Accept) { result = t_CheckerboardTool1.RunStatus.Result; message = \u0026#34;CheckerboardTool1 Run ERROR\u0026#34;; return false; } t_NPointToNPointTool1.InputImage = t_CheckerboardTool1.OutputImage; t_NPointToNPointTool1.Run(); if (t_NPointToNPointTool1.RunStatus.Result != CogToolResultConstants.Accept) { result = t_NPointToNPointTool1.RunStatus.Result; message = \u0026#34;NPointToNPointTool1 Run ERROR\u0026#34;; return false; } t_FixtureTool1.InputImage = t_NPointToNPointTool1.OutputImage; CogTransform2DLinear t_CogTransform2DLinear1 = (CogTransform2DLinear) t_FixtureTool1.RunParams.UnfixturedFromFixturedTransform; double t_CalibRZ = (double) mToolBlock.Inputs[\u0026#34;CalibRZ\u0026#34;].Value; t_CogTransform2DLinear1.Rotation = (t_CalibRZ-t_CurrentRZ) / 180 * Math.PI * t_InverseRzInt; t_FixtureTool1.RunParams.UnfixturedFromFixturedTransform = t_CogTransform2DLinear1; t_FixtureTool1.Run(); if (t_FixtureTool1.RunStatus.Result != CogToolResultConstants.Accept) { result = t_FixtureTool1.RunStatus.Result; message = \u0026#34;FixtureTool1 Run ERROR\u0026#34;; return false; } t_FixtureTool2.InputImage = t_FixtureTool1.OutputImage; CogTransform2DLinear t_CogTransform2DLinear2 = (CogTransform2DLinear) t_FixtureTool2.RunParams.UnfixturedFromFixturedTransform; t_CogTransform2DLinear2.Rotation = 0; t_CogTransform2DLinear2.TranslationX = -t_CurrentX; t_CogTransform2DLinear2.TranslationY = -t_CurrentY; t_FixtureTool2.RunParams.UnfixturedFromFixturedTransform = t_CogTransform2DLinear2; t_FixtureTool2.Run(); if (t_FixtureTool2.RunStatus.Result != CogToolResultConstants.Accept) { result = t_FixtureTool2.RunStatus.Result; message = \u0026#34;FixtureTool2 Run ERROR\u0026#34;; return false; } mToolBlock.Outputs[\u0026#34;OutputImage\u0026#34;].Value = t_FixtureTool2.OutputImage; t_Label.SetXYText(200, 300, \u0026#34;Space 转换成功！\u0026#34;); m_GraphicCollection.Add(t_Label.Copy(CogCopyShapeConstants.All)); result = CogToolResultConstants.Accept; #endregion } else { result = CogToolResultConstants.Error; message = \u0026#34;Commandstr 运行模式 参数错误\u0026#34;; t_Label.SetXYText(200, 300, \u0026#34;RunMode 运行模式 参数错误\u0026#34;); m_GraphicCollection.Add(t_Label.Copy(CogCopyShapeConstants.All)); } mToolBlock.Outputs[\u0026#34;OutputGraphics\u0026#34;].Value = m_GraphicCollection; return false; } #region When the Current Run Record is Created /// \u0026lt;summary\u0026gt; /// Called when the current record may have changed and is being reconstructed /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;currentRecord\u0026#34;\u0026gt; /// The new currentRecord is available to be initialized or customized.\u0026lt;/param\u0026gt; public override void ModifyCurrentRunRecord(Cognex.VisionPro.ICogRecord currentRecord) { } #endregion #region When the Last Run Record is Created /// \u0026lt;summary\u0026gt; /// Called when the last run record may have changed and is being reconstructed /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;lastRecord\u0026#34;\u0026gt; /// The new last run record is available to be initialized or customized.\u0026lt;/param\u0026gt; public override void ModifyLastRunRecord(Cognex.VisionPro.ICogRecord lastRecord) { for(int i = 0;i \u0026lt; m_GraphicCollection.Count ;i++) { mToolBlock.AddGraphicToRunRecord(m_GraphicCollection[i], lastRecord, \u0026#34;CogFixtureTool1.OutputImage\u0026#34;, \u0026#34;script\u0026#34;); } } #endregion #region When the Script is Initialized /// \u0026lt;summary\u0026gt; /// Perform any initialization required by your script here /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;host\u0026#34;\u0026gt;The host tool\u0026lt;/param\u0026gt; public override void Initialize(Cognex.VisionPro.ToolGroup.CogToolGroup host) { // DO NOT REMOVE - Call the base class implementation first - DO NOT REMOVE base.Initialize(host); // Store a local copy of the script host this.mToolBlock = ((Cognex.VisionPro.ToolBlock.CogToolBlock)(host)); } #endregion } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 #region namespace imports using System; using System.Collections; using System.Drawing; using System.IO; using System.Windows.Forms; using Cognex.VisionPro; using Cognex.VisionPro.ToolBlock; using Cognex.VisionPro3D; using Cognex.VisionPro.PMAlign; using Cognex.VisionPro.CalibFix; using Cognex.VisionPro.Caliper; #endregion public class CogToolBlockAdvancedScript : CogToolBlockAdvancedScriptBase { #region Private Member Variables private Cognex.VisionPro.ToolBlock.CogToolBlock mToolBlock; private CogGraphicCollection m_GraphicCollection ; #endregion /// \u0026lt;summary\u0026gt; /// Called when the parent tool is run. /// Add code here to customize or replace the normal run behavior. /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;message\u0026#34;\u0026gt;Sets the Message in the tool\u0026#39;s RunStatus.\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;result\u0026#34;\u0026gt;Sets the Result in the tool\u0026#39;s RunStatus\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;True if the tool should run normally, /// False if GroupRun customizes run behavior\u0026lt;/returns\u0026gt; public override bool GroupRun(ref string message, ref CogToolResultConstants result) { // To let the execution stop in this script when a debugger is attached, uncomment the following lines. // #if DEBUG // if (System.Diagnostics.Debugger.IsAttached) System.Diagnostics.Debugger.Break(); // #endif // Run each tool using the RunTool function //foreach(ICogTool tool in mToolBlock.Tools) // mToolBlock.RunTool(tool, ref message, ref result); //显示状态集 if(m_GraphicCollection == null) { m_GraphicCollection = new CogGraphicCollection(); } else { m_GraphicCollection.Clear(); } CogImage8Grey t_InputImage = (CogImage8Grey) mToolBlock.Inputs[\u0026#34;InputImage\u0026#34;].Value; double t_Radius_Min = (double) mToolBlock.Inputs[\u0026#34;Radius_Min\u0026#34;].Value; double t_Radius_Max = (double) mToolBlock.Inputs[\u0026#34;Radius_Max\u0026#34;].Value; int t_Circle_points = (int) mToolBlock.Inputs[\u0026#34;Circle_points\u0026#34;].Value; if (t_InputImage == null) { result = CogToolResultConstants.Error; message = \u0026#34;FindMarkPoint 未输入图像!\u0026#34;; return false; } string t_RootSpaceName = t_InputImage.SelectedSpaceName; CogPMAlignTool t_PMAlignTool1 = (CogPMAlignTool) mToolBlock.Tools[\u0026#34;CogPMAlignTool1\u0026#34;]; CogFixtureTool t_FixtureTool1 = (CogFixtureTool) mToolBlock.Tools[\u0026#34;CogFixtureTool1\u0026#34;]; CogFindCircleTool t_FindCircleTool1 = (CogFindCircleTool) mToolBlock.Tools[\u0026#34;CogFindCircleTool1\u0026#34;]; if( t_PMAlignTool1.SearchRegion is Cognex.VisionPro.CogRectangleAffine) { CogRectangleAffine t_CogRectangleAffine = (CogRectangleAffine) t_PMAlignTool1.SearchRegion; CogRectangleAffine t_CogRectangleAffine1 = t_CogRectangleAffine.Copy(CogCopyShapeConstants.All); t_CogRectangleAffine1.Interactive = false; m_GraphicCollection.Add(t_CogRectangleAffine1); } if( t_PMAlignTool1.SearchRegion is Cognex.VisionPro.CogCircle) { CogCircle t_CogCircle = (CogCircle) t_PMAlignTool1.SearchRegion; CogCircle t_CogCircle1 = t_CogCircle.Copy(CogCopyShapeConstants.All); t_CogCircle1.Interactive = false; m_GraphicCollection.Add(t_CogCircle1); } t_PMAlignTool1.InputImage = t_InputImage; t_PMAlignTool1.Run(); if (t_PMAlignTool1.RunStatus.Result != CogToolResultConstants.Accept) { result = t_PMAlignTool1.RunStatus.Result; message = \u0026#34;CogPMAlignTool1 Run Error!\u0026#34;; return false; } if (t_PMAlignTool1.Results == null || t_PMAlignTool1.Results.Count == 0) { result = CogToolResultConstants.Error; message = \u0026#34;未匹配到结果\u0026#34;; return false; } CogPMAlignResult[] t_PMAlignResults = new CogPMAlignResult[t_PMAlignTool1.Results.Count]; for (int i = 0; i \u0026lt; t_PMAlignTool1.Results.Count; i++) { t_PMAlignResults[i] = t_PMAlignTool1.Results[i]; } //冒泡排序 CogPMAlignResult t_PMAlignResult; for (int i = 0; i \u0026lt; t_PMAlignTool1.Results.Count; i++) { for (int j = i + 1; j \u0026lt; t_PMAlignTool1.Results.Count; j++) { if (t_PMAlignResults[j].Score \u0026gt; t_PMAlignResults[i].Score) { t_PMAlignResult = t_PMAlignResults[i]; t_PMAlignResults[i] = t_PMAlignResults[j]; t_PMAlignResults[j] = t_PMAlignResult; } } } t_PMAlignResult = t_PMAlignResults[0]; //显示搜索区域 CogTransform2DLinear t_CogTransform2DLinear= (CogTransform2DLinear)t_InputImage.GetTransform(\u0026#34;#\u0026#34;, t_RootSpaceName); CogCompositeShape t_CogCompositeShape = t_PMAlignResult.CreateResultGraphics(CogPMAlignResultGraphicConstants.MatchRegion); CogRectangleAffine t_CogRectangleAffine2 = (CogRectangleAffine) t_CogCompositeShape.Children[0]; CogRectangleAffine t_CogRectangleAffine3 = t_CogRectangleAffine2.MapLinear(t_CogTransform2DLinear, CogCopyShapeConstants.All); t_CogRectangleAffine3.Interactive = false; t_CogRectangleAffine3.SelectedSpaceName = \u0026#34;#\u0026#34;; m_GraphicCollection.Add(t_CogRectangleAffine3); //显示搜索区域 t_FixtureTool1.InputImage = t_InputImage; t_FixtureTool1.RunParams.UnfixturedFromFixturedTransform = t_PMAlignResult.GetPose(); t_FixtureTool1.Run(); if (t_FixtureTool1.RunStatus.Result != CogToolResultConstants.Accept) { result = t_FixtureTool1.RunStatus.Result; message = \u0026#34;CogFixtureTool1 Run Error!\u0026#34;; return false; } t_FindCircleTool1.InputImage = (CogImage8Grey)t_FixtureTool1.OutputImage; t_FindCircleTool1.Run(); if (t_FindCircleTool1.RunStatus.Result != CogToolResultConstants.Accept) { result = t_FindCircleTool1.RunStatus.Result; message = \u0026#34;CogFindCircleTool1 Run Error!\u0026#34;; return false; } if(t_FindCircleTool1.Results == null || t_FindCircleTool1.Results.GetCircle() == null) { result = CogToolResultConstants.Error; message = \u0026#34;未搜索到圆\u0026#34;; return false; } string t_CurrentSpaceName = t_FixtureTool1.OutputImage.SelectedSpaceName; ICogTransform2D t_Transform2D= t_FixtureTool1.OutputImage.GetTransform(t_RootSpaceName, t_CurrentSpaceName); CogCircle t_Circle = t_FindCircleTool1.Results.GetCircle(); if(t_Circle.Radius \u0026lt; t_Radius_Min || t_Circle.Radius \u0026gt; t_Radius_Max) { result = CogToolResultConstants.Error; message = \u0026#34;搜索到的园半径不在范围之内，请检查圆是否异常\u0026#34;; return false; } if(t_FindCircleTool1.Results.NumPointsFound \u0026lt; t_Circle_points) { result = CogToolResultConstants.Error; message = \u0026#34;搜索到的圆卡尺数量不在范围之内,请检查圆是否异常\u0026#34;; return false; } double t_OutputX,t_OutputY; t_Transform2D.MapPoint(t_Circle.CenterX, t_Circle.CenterY,out t_OutputX,out t_OutputY); mToolBlock.Outputs[\u0026#34;OutputX\u0026#34;].Value = t_OutputX; mToolBlock.Outputs[\u0026#34;OutputY\u0026#34;].Value = t_OutputY; //显示Mark点 double t_MarkX,t_MarkY; t_CogTransform2DLinear.MapPoint(t_OutputX, t_OutputY, out t_MarkX, out t_MarkY); CogPointMarker t_CogPointMarker = new CogPointMarker(); t_CogPointMarker.X = t_MarkX; t_CogPointMarker.Y = t_MarkY; t_CogPointMarker.SizeInScreenPixels = 20; t_CogPointMarker.LineWidthInScreenPixels = 3; t_CogPointMarker.SelectedSpaceName = \u0026#34;#\u0026#34;; m_GraphicCollection.Add(t_CogPointMarker.Copy(CogCopyShapeConstants.All)); //显示Mark点 t_CogTransform2DLinear = (CogTransform2DLinear) t_FixtureTool1.OutputImage.GetTransform(\u0026#34;#\u0026#34;, t_CurrentSpaceName); //显示找到的圆 CogEllipse t_CogEllipse = t_Circle.MapLinear(t_CogTransform2DLinear, CogCopyShapeConstants.All); t_CogEllipse.SelectedSpaceName = \u0026#34;#\u0026#34;; m_GraphicCollection.Add(t_CogEllipse.Copy(CogCopyShapeConstants.All)); //显示找到的圆 //显示Mark点坐标 CogGraphicLabel t_CogGraphicLabel = new CogGraphicLabel(); t_CogGraphicLabel.Font = new System.Drawing.Font(\u0026#34;楷体\u0026#34;, 24); t_CogGraphicLabel.X = t_CogRectangleAffine3.CornerOriginX; t_CogGraphicLabel.Y = t_CogRectangleAffine3.CornerOriginY; //t_CogGraphicLabel.Rotation = t_CogRectangleAffine3.Rotation; t_CogGraphicLabel.Alignment = CogGraphicLabelAlignmentConstants.BottomLeft; t_CogGraphicLabel.Text = \u0026#34;X：\u0026#34; + t_OutputX.ToString(\u0026#34;0.00\u0026#34;) + \u0026#34;; \u0026#34; + \u0026#34;Y：\u0026#34; + t_OutputY.ToString(\u0026#34;0.00\u0026#34;); t_CogGraphicLabel.Color = CogColorConstants.Blue; t_CogGraphicLabel.SelectedSpaceName = \u0026#34;#\u0026#34;; m_GraphicCollection.Add(t_CogGraphicLabel.Copy(CogCopyShapeConstants.All)); //显示Mark点坐标 mToolBlock.Outputs[\u0026#34;OutputGraphics\u0026#34;].Value = m_GraphicCollection; return false; } #region When the Current Run Record is Created /// \u0026lt;summary\u0026gt; /// Called when the current record may have changed and is being reconstructed /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;currentRecord\u0026#34;\u0026gt; /// The new currentRecord is available to be initialized or customized.\u0026lt;/param\u0026gt; public override void ModifyCurrentRunRecord(Cognex.VisionPro.ICogRecord currentRecord) { } #endregion #region When the Last Run Record is Created /// \u0026lt;summary\u0026gt; /// Called when the last run record may have changed and is being reconstructed /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;lastRecord\u0026#34;\u0026gt; /// The new last run record is available to be initialized or customized.\u0026lt;/param\u0026gt; public override void ModifyLastRunRecord(Cognex.VisionPro.ICogRecord lastRecord) { for(int i = 0;i \u0026lt; m_GraphicCollection.Count ;i++) { mToolBlock.AddGraphicToRunRecord(m_GraphicCollection[i], lastRecord, \u0026#34;CogPMAlignTool1.InputImage\u0026#34;, \u0026#34;script\u0026#34;); } } #endregion #region When the Script is Initialized /// \u0026lt;summary\u0026gt; /// Perform any initialization required by your script here /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;host\u0026#34;\u0026gt;The host tool\u0026lt;/param\u0026gt; public override void Initialize(Cognex.VisionPro.ToolGroup.CogToolGroup host) { // DO NOT REMOVE - Call the base class implementation first - DO NOT REMOVE base.Initialize(host); // Store a local copy of the script host this.mToolBlock = ((Cognex.VisionPro.ToolBlock.CogToolBlock)(host)); } #endregion } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 #region namespace imports using System; using System.Collections; using System.Drawing; using System.IO; using System.Windows.Forms; using Cognex.VisionPro; using Cognex.VisionPro.ToolBlock; using Cognex.VisionPro3D; using Cognex.VisionPro.CalibFix; #endregion public class CogToolBlockAdvancedScript : CogToolBlockAdvancedScriptBase { #region Private Member Variables private Cognex.VisionPro.ToolBlock.CogToolBlock mToolBlock; #endregion /// \u0026lt;summary\u0026gt; /// Called when the parent tool is run. /// Add code here to customize or replace the normal run behavior. /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;message\u0026#34;\u0026gt;Sets the Message in the tool\u0026#39;s RunStatus.\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;result\u0026#34;\u0026gt;Sets the Result in the tool\u0026#39;s RunStatus\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;True if the tool should run normally, /// False if GroupRun customizes run behavior\u0026lt;/returns\u0026gt; public override bool GroupRun(ref string message, ref CogToolResultConstants result) { // To let the execution stop in this script when a debugger is attached, uncomment the following lines. // #if DEBUG // if (System.Diagnostics.Debugger.IsAttached) System.Diagnostics.Debugger.Break(); // #endif // Run each tool using the RunTool function // foreach(ICogTool tool in mToolBlock.Tools) // mToolBlock.RunTool(tool, ref message, ref result); CogImage8Grey t_InputImage = (CogImage8Grey) mToolBlock.Inputs[\u0026#34;InputImage\u0026#34;].Value; double t_TrainX1 = (double)mToolBlock.Inputs[\u0026#34;TrainX1\u0026#34;].Value; double t_TrainY1 = (double) mToolBlock.Inputs[\u0026#34;TrainY1\u0026#34;].Value; double t_TrainX2 = (double) mToolBlock.Inputs[\u0026#34;TrainX2\u0026#34;].Value; double t_TrainY2 = (double) mToolBlock.Inputs[\u0026#34;TrainY2\u0026#34;].Value; double t_CurrentX1 = (double) mToolBlock.Inputs[\u0026#34;CurrentX1\u0026#34;].Value; double t_CurrentY1 = (double) mToolBlock.Inputs[\u0026#34;CurrentY1\u0026#34;].Value; double t_CurrentX2 = (double) mToolBlock.Inputs[\u0026#34;CurrentX2\u0026#34;].Value; double t_CurrentY2 = (double) mToolBlock.Inputs[\u0026#34;CurrentY2\u0026#34;].Value; if (t_InputImage == null) { result = CogToolResultConstants.Error; message = \u0026#34;FindMarkPoint 未输入图像!\u0026#34;; return false; } string t_RootSpaceName = t_InputImage.SelectedSpaceName; CogFixtureNPointToNPointTool t_FixtureNPointToNPointTool1 = (CogFixtureNPointToNPointTool) mToolBlock.Tools[\u0026#34;CogFixtureNPointToNPointTool1\u0026#34;]; t_FixtureNPointToNPointTool1.RunParams.SetUnfixturedPoint(0, t_TrainX1, t_TrainY1); t_FixtureNPointToNPointTool1.RunParams.SetUnfixturedPoint (1, t_TrainX2, t_TrainY2); t_FixtureNPointToNPointTool1.RunParams.SetRawFixturedPoint(0, t_CurrentX1, t_CurrentY1); t_FixtureNPointToNPointTool1.RunParams.SetRawFixturedPoint(1, t_CurrentX2, t_CurrentY2); t_FixtureNPointToNPointTool1.InputImage = t_InputImage; t_FixtureNPointToNPointTool1.Run(); if (t_FixtureNPointToNPointTool1.RunStatus.Result != CogToolResultConstants.Accept) { result = t_FixtureNPointToNPointTool1.RunStatus.Result; message = \u0026#34;CogFixtureNPointToNPointTool1 Run Error!\u0026#34;; return false; } string t_CurrentSpaceName = t_FixtureNPointToNPointTool1.Result.OutputImage.SelectedSpaceName; // ICogTransform2D t_Transform2D = t_FixtureNPointToNPointTool1.Result.OutputImage.GetTransform(t_CurrentSpaceName, t_RootSpaceName); ICogTransform2D t_Transform2D = t_FixtureNPointToNPointTool1.Result.GetUnfixturedFromFixturedTransform().InvertBase(); mToolBlock.Outputs[\u0026#34;OutputTransform2D\u0026#34;].Value = t_Transform2D; mToolBlock.Outputs[\u0026#34;OutputRMS\u0026#34;].Value = t_FixtureNPointToNPointTool1.Result.RMSError; return false; } #region When the Current Run Record is Created /// \u0026lt;summary\u0026gt; /// Called when the current record may have changed and is being reconstructed /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;currentRecord\u0026#34;\u0026gt; /// The new currentRecord is available to be initialized or customized.\u0026lt;/param\u0026gt; public override void ModifyCurrentRunRecord(Cognex.VisionPro.ICogRecord currentRecord) { } #endregion #region When the Last Run Record is Created /// \u0026lt;summary\u0026gt; /// Called when the last run record may have changed and is being reconstructed /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;lastRecord\u0026#34;\u0026gt; /// The new last run record is available to be initialized or customized.\u0026lt;/param\u0026gt; public override void ModifyLastRunRecord(Cognex.VisionPro.ICogRecord lastRecord) { } #endregion #region When the Script is Initialized /// \u0026lt;summary\u0026gt; /// Perform any initialization required by your script here /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;host\u0026#34;\u0026gt;The host tool\u0026lt;/param\u0026gt; public override void Initialize(Cognex.VisionPro.ToolGroup.CogToolGroup host) { // DO NOT REMOVE - Call the base class implementation first - DO NOT REMOVE base.Initialize(host); // Store a local copy of the script host this.mToolBlock = ((Cognex.VisionPro.ToolBlock.CogToolBlock)(host)); } #endregion } ","date":"2025-01-25T00:00:00Z","permalink":"https://zihui7896.github.io/p/visionpro-fhs/","title":"VisionPro-FHS"}]